/**
 * Copyright 2009-2012 TU Dortmund
 *
 * This file is part of FoXLib.
 *
 * FoXLib is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FoXLib is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with BonXai.  If not, see <http://www.gnu.org/licenses/>.
 */

package eu.fox7.schematoolkit.converter.xsd2bonxai;


import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections15.BidiMap;

import eu.fox7.flt.automata.impl.sparse.State;
import eu.fox7.schematoolkit.AbstractSchemaConverter;
import eu.fox7.schematoolkit.Schema;
import eu.fox7.schematoolkit.SchemaHandler;
import eu.fox7.schematoolkit.SchemaLanguage;
import eu.fox7.schematoolkit.SchemaToolkitException;
import eu.fox7.schematoolkit.bonxai.om.AncestorPattern;
import eu.fox7.schematoolkit.bonxai.om.Annotation;
import eu.fox7.schematoolkit.bonxai.om.AttributePattern;
import eu.fox7.schematoolkit.bonxai.om.Bonxai;
import eu.fox7.schematoolkit.bonxai.om.BonxaiGroup;
import eu.fox7.schematoolkit.bonxai.om.BonxaiType;
import eu.fox7.schematoolkit.bonxai.om.ChildPattern;
import eu.fox7.schematoolkit.bonxai.om.ElementPattern;
import eu.fox7.schematoolkit.bonxai.om.Expression;
import eu.fox7.schematoolkit.common.AttributeParticle;
import eu.fox7.schematoolkit.common.DefaultNamespace;
import eu.fox7.schematoolkit.common.ElementProperties;
import eu.fox7.schematoolkit.common.EmptyPattern;
import eu.fox7.schematoolkit.common.IdentifiedNamespace;
import eu.fox7.schematoolkit.common.Particle;
import eu.fox7.schematoolkit.common.QualifiedName;
import eu.fox7.schematoolkit.exceptions.ConversionFailedException;
import eu.fox7.schematoolkit.typeautomaton.TypeAutomaton;
import eu.fox7.schematoolkit.typeautomaton.factories.XSDTypeAutomatonFactory;
import eu.fox7.schematoolkit.xsd.XSDSchemaHandler;
import eu.fox7.schematoolkit.xsd.om.Attribute;
import eu.fox7.schematoolkit.xsd.om.ComplexContentType;
import eu.fox7.schematoolkit.xsd.om.ComplexType;
import eu.fox7.schematoolkit.xsd.om.Content;
import eu.fox7.schematoolkit.xsd.om.Element;
import eu.fox7.schematoolkit.xsd.om.Group;
import eu.fox7.schematoolkit.xsd.om.SimpleContentType;
import eu.fox7.schematoolkit.xsd.om.Type;
import eu.fox7.schematoolkit.xsd.om.XSDSchema;
import eu.fox7.schematoolkit.xsd.om.XSDSchema.Qualification;


/**
 * Main class to perform transformation from {@link eu.fox7.schematoolkit.xsd.om.XSDSchema} to {bonxai.Bonxai}.
 *
 * An instance of this class is used to transform an {@link eu.fox7.schematoolkit.xsd.om.XSDSchema},
 * generated by the XML XSDSchema parser to a valid {@link eu.fox7.schematoolkit.bonxai.om.Bonxai} instance. It
 * is meant to be used directly in the tool that will perform this conversion.
 */
public class XSD2BonxaiConverter extends AbstractSchemaConverter {
	public static void main (String[] args) {
		if (args.length != 2) {
			System.err.println("Usage: XSD2BonXaiconverter input.xsd output.bonxai");
			return;
		}
		SchemaHandler sh = new XSDSchemaHandler();
		try {
			sh.loadSchema(new File(args[0]));
			SchemaHandler target = sh.convert(SchemaLanguage.BONXAI);
			target.writeSchema(new File(args[1]));
		} catch (SchemaToolkitException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/**
     * The schema to convert.
     */
    private XSDSchema schema;

    /**
     * TypeAutomaton used for conversion
     */
    private TypeAutomaton typeAutomaton;
		
	private Bonxai bonxai;
	
	private ParticleProcessor particleProcessor;
	
	private AttributeProcessor attributeProcessor;
	
	private BidiMap<State, Type> stateTypeMap;
	
	private Map<State, Expression> stateExpressionMap;
	
	private Map<Expression, Set<State>> expressionStateMap;
	
	private XSDSchema xmlSchema;
	
	private boolean addExpressionsForBonxaiTypes = true;
	
	private AncestorPatternBuilder ancestorPatternBuilder;
    
    /**
	 * @return the typeAutomaton
	 */
	public TypeAutomaton getTypeAutomaton() {
		return typeAutomaton;
	}

	/**
	 * @return the stateTypeMap
	 */
	public BidiMap<State, Type> getStateTypeMap() {
		return stateTypeMap;
	}

	/**
	 * @return the stateExpressionMap
	 */
	public Map<State, Expression> getStateExpressionMap() {
		return stateExpressionMap;
	}

	/**
	 * @return the expressionStateMap
	 */
	public Map<Expression, Set<State>> getExpressionStateMap() {
		return expressionStateMap;
	}

	/**
     * Creates a new XSD2BonxaiConverter for the given schema.
     */
    public XSD2BonxaiConverter( ) {
    }
    
    public XSD2BonxaiConverter(boolean addExpressionsForBonxaiTypes) {
    	this.addExpressionsForBonxaiTypes = addExpressionsForBonxaiTypes;
    }
    
    public Bonxai convert(Schema schema ) throws ConversionFailedException {
    	if (!(schema instanceof XSDSchema))
    		throw new ConversionFailedException("Can only convert XML Schema schemas.");
    	
    	if (this.ancestorPatternBuilder == null) {
    		this.ancestorPatternBuilder = new AncestryAncestorPatternBuilder();
    	}
    	
    	xmlSchema = (XSDSchema) schema;
    	this.attributeProcessor = new AttributeProcessor(xmlSchema.getTargetNamespace().getUri());
    	this.particleProcessor = new ParticleProcessor(xmlSchema, !this.addExpressionsForBonxaiTypes);
    	XSDTypeAutomatonFactory factory = new XSDTypeAutomatonFactory(this.addExpressionsForBonxaiTypes);
    	this.schema = xmlSchema;

    	this.typeAutomaton = factory.createTypeAutomaton(xmlSchema);
    	
    	System.err.println("TypeAutomaton: " + typeAutomaton);
    	
    	bonxai = new Bonxai();
    	
    	createGroups();
    	createDeclaration();
    	createExpressions();

    	return bonxai;
    }
    
    private void createGroups() {
		for (Group group: xmlSchema.getGroups()) {
			Particle particle = group.getParticle();
			Particle bonxaiParticle = particleProcessor.convertParticle(particle);
			BonxaiGroup bonxaiGroup = new BonxaiGroup(group.getName(), bonxaiParticle);
			bonxai.addGroup(bonxaiGroup);
		}
	}

	private void createExpressions() {
		Map<State,AncestorPattern> map = this.ancestorPatternBuilder.buildAncestorPatterns(typeAutomaton, bonxai.getNamespaceList());
		
		for (Map.Entry<State, AncestorPattern> e: map.entrySet()) {
			State state = e.getKey();
			AncestorPattern ancestorPattern = e.getValue();
			
			ChildPattern childPattern = createChildPattern(state);
			
			Expression expression = new Expression();
			expression.setAncestorPattern(ancestorPattern);
			expression.setChildPattern(childPattern);

			Type type = typeAutomaton.getType(state);
			if ((type != null) && (!type.isAnonymous()) && (expression.getChildPattern().getElementPattern().getBonxaiType()==null))
					expression.addAnnotation(new Annotation("typename",this.typeAutomaton.getTypeName(state).getName()));
			
			bonxai.addExpression(expression);
		}
		
    	Collection<Element> rootElements = schema.getElements();
    	for (Element rootElement: rootElements) {
    		bonxai.addRootElementName(rootElement.getName());
    	}
    	
    	Collection<Attribute> rootAttributes = schema.getAttributes();
    	for (Attribute rootAttribute: rootAttributes) {
    		bonxai.addRootElementName(rootAttribute.getName());
    	}
	}

	private void createDeclaration() {
		DefaultNamespace targetNamespace = new DefaultNamespace(schema.getTargetNamespace().getUri());
		bonxai.setTargetNamespace(targetNamespace);
		
		for (IdentifiedNamespace namespace: schema.getNamespaces()) {
			bonxai.addNamespace(namespace);
		}
	}
    

	private ChildPattern createChildPattern(State state) {
		Type type = typeAutomaton.getType(state);
		QualifiedName typename = typeAutomaton.getTypeName(state);
		ElementProperties elementProperties = typeAutomaton.getElementProperties(state);
		AttributePattern attributePattern = new AttributePattern();
		Particle particle = null;
		boolean mixed = false;
		if (type == null) {
			
		} else if (type instanceof ComplexType) {
			ComplexType complexType = (ComplexType) type;
			List<AttributeParticle> attributeParticles = complexType.getAttributes();
			attributePattern = convertAttributeParticles(attributeParticles);
			
			Content content = ((ComplexType) type).getContent();
			if (content instanceof ComplexContentType) {
				ComplexContentType complexContentType = (ComplexContentType) content;
				mixed = complexContentType.getMixed();
				particle = convertParticle(complexContentType.getParticle());
			} else if (content instanceof SimpleContentType) {
//				SimpleContentType simpleContentType = (SimpleContentType) content;
				particle = new EmptyPattern();
			} else if (content == null) {
				//TODO
				particle = new EmptyPattern();
			} else {
				throw new RuntimeException("Only complex content types allowed.");
			}
		
		} 
//		else {
//			throw new RuntimeException("Only complex types allowed.");
//		}
		ElementPattern elementPattern = null;
		if (particle == null)
			elementPattern = new ElementPattern(new BonxaiType(typename));
		else
			elementPattern = new ElementPattern(particle);
		elementPattern.setDefaultValue(elementProperties.getDefaultValue());
		elementPattern.setFixedValue(elementProperties.getFixedValue());
		ChildPattern childPattern = new ChildPattern(attributePattern, elementPattern, mixed, elementProperties.isNillable());
		return childPattern;
	}

	private AttributePattern convertAttributeParticles(List<AttributeParticle> attributeParticles) {
		return attributeProcessor.convertAttributes(attributeParticles);
	}

	private Particle convertParticle(Particle particle) {
		return particleProcessor.convertParticle(particle);
	}


}
