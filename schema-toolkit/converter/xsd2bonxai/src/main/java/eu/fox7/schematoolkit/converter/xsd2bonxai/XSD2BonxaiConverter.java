/**
 * Copyright 2009-2012 TU Dortmund
 *
 * This file is part of FoXLib.
 *
 * FoXLib is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FoXLib is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with BonXai.  If not, see <http://www.gnu.org/licenses/>.
 */

package eu.fox7.schematoolkit.converter.xsd2bonxai;


import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import org.apache.commons.collections15.BidiMap;

import eu.fox7.flt.automata.impl.sparse.ModifiableStateDFA;
import eu.fox7.flt.automata.impl.sparse.SparseNFA;
import eu.fox7.flt.automata.impl.sparse.State;
import eu.fox7.flt.regex.Regex;
import eu.fox7.flt.regex.converters.EpsilonEmptyEliminator;
import eu.fox7.flt.regex.converters.Normalizer;
import eu.fox7.flt.regex.factories.StateEliminationFactory;
import eu.fox7.schematoolkit.AbstractSchemaConverter;
import eu.fox7.schematoolkit.Schema;
import eu.fox7.schematoolkit.bonxai.om.AncestorPattern;
import eu.fox7.schematoolkit.bonxai.om.AncestorPatternElement;
import eu.fox7.schematoolkit.bonxai.om.Annotation;
import eu.fox7.schematoolkit.bonxai.om.AttributePattern;
import eu.fox7.schematoolkit.bonxai.om.Bonxai;
import eu.fox7.schematoolkit.bonxai.om.BonxaiGroup;
import eu.fox7.schematoolkit.bonxai.om.BonxaiType;
import eu.fox7.schematoolkit.bonxai.om.CardinalityParticle;
import eu.fox7.schematoolkit.bonxai.om.ChildPattern;
import eu.fox7.schematoolkit.bonxai.om.ElementPattern;
import eu.fox7.schematoolkit.bonxai.om.Expression;
import eu.fox7.schematoolkit.bonxai.om.OrExpression;
import eu.fox7.schematoolkit.bonxai.om.SequenceExpression;
import eu.fox7.schematoolkit.common.AttributeParticle;
import eu.fox7.schematoolkit.common.DefaultNamespace;
import eu.fox7.schematoolkit.common.ElementProperties;
import eu.fox7.schematoolkit.common.EmptyPattern;
import eu.fox7.schematoolkit.common.IdentifiedNamespace;
import eu.fox7.schematoolkit.common.Namespace;
import eu.fox7.schematoolkit.common.Particle;
import eu.fox7.schematoolkit.common.QualifiedName;
import eu.fox7.schematoolkit.exceptions.ConversionFailedException;
import eu.fox7.schematoolkit.typeautomaton.TypeAutomaton;
import eu.fox7.schematoolkit.typeautomaton.factories.XSDTypeAutomatonFactory;
import eu.fox7.schematoolkit.xsd.om.ComplexContentType;
import eu.fox7.schematoolkit.xsd.om.ComplexType;
import eu.fox7.schematoolkit.xsd.om.Content;
import eu.fox7.schematoolkit.xsd.om.Element;
import eu.fox7.schematoolkit.xsd.om.Group;
import eu.fox7.schematoolkit.xsd.om.SimpleContentType;
import eu.fox7.schematoolkit.xsd.om.Type;
import eu.fox7.schematoolkit.xsd.om.XSDSchema;
import eu.fox7.schematoolkit.xsd.om.XSDSchema.Qualification;
import eu.fox7.util.tree.Node;
import eu.fox7.util.tree.Tree;


/**
 * Main class to perform transformation from {@link eu.fox7.schematoolkit.xsd.om.XSDSchema} to {bonxai.Bonxai}.
 *
 * An instance of this class is used to transform an {@link eu.fox7.schematoolkit.xsd.om.XSDSchema},
 * generated by the XML XSDSchema parser to a valid {@link eu.fox7.schematoolkit.bonxai.om.Bonxai} instance. It
 * is meant to be used directly in the tool that will perform this conversion.
 */
public class XSD2BonxaiConverter extends AbstractSchemaConverter {
    /**
     * The schema to convert.
     */
    private XSDSchema schema;

    /**
     * TypeAutomaton used for conversion
     */
    private TypeAutomaton typeAutomaton;
	
	private Qualification elementFormDefault;
	
	private Bonxai bonxai;
	
	private ParticleProcessor particleProcessor;
	
	private AttributeProcessor attributeProcessor;
	
	private BidiMap<State, Type> stateTypeMap;
	
	private Map<State, Expression> stateExpressionMap;
	
	private Map<Expression, Set<State>> expressionStateMap;
	
	private XSDSchema xmlSchema;
	
	private boolean addExpressionsForBonxaiTypes = true;
    
    /**
	 * @return the typeAutomaton
	 */
	public TypeAutomaton getTypeAutomaton() {
		return typeAutomaton;
	}

	/**
	 * @return the stateTypeMap
	 */
	public BidiMap<State, Type> getStateTypeMap() {
		return stateTypeMap;
	}

	/**
	 * @return the stateExpressionMap
	 */
	public Map<State, Expression> getStateExpressionMap() {
		return stateExpressionMap;
	}

	/**
	 * @return the expressionStateMap
	 */
	public Map<Expression, Set<State>> getExpressionStateMap() {
		return expressionStateMap;
	}

	/**
     * Creates a new XSD2BonxaiConverter for the given schema.
     */
    public XSD2BonxaiConverter( ) {
    }
    
    public XSD2BonxaiConverter(boolean addExpressionsForBonxaiTypes) {
    	this.addExpressionsForBonxaiTypes = addExpressionsForBonxaiTypes;
    }
    
    public Bonxai convert(Schema schema ) throws ConversionFailedException {
    	if (!(schema instanceof XSDSchema))
    		throw new ConversionFailedException("Can only convert XML Schema schemas.");
    	xmlSchema = (XSDSchema) schema;
    	this.attributeProcessor = new AttributeProcessor(xmlSchema);
    	this.particleProcessor = new ParticleProcessor(xmlSchema, !this.addExpressionsForBonxaiTypes);
    	XSDTypeAutomatonFactory factory = new XSDTypeAutomatonFactory(this.addExpressionsForBonxaiTypes);
    	this.schema = xmlSchema;
    	this.elementFormDefault = xmlSchema.getElementFormDefault();

    	this.typeAutomaton = factory.createTypeAutomaton(xmlSchema);
    	
    	bonxai = new Bonxai();
    	
    	createGroups();
    	createDeclaration();
    	createExpressions();

    	return bonxai;
    }
    
    private void createGroups() {
		for (Group group: xmlSchema.getGroups()) {
			Particle particle = group.getParticle();
			Particle bonxaiParticle = particleProcessor.convertParticle(particle);
			BonxaiGroup bonxaiGroup = new BonxaiGroup(group.getName(), bonxaiParticle);
			bonxai.addGroup(bonxaiGroup);
		}
	}

	private void createExpressions() {
    	for (State state: typeAutomaton.getStates()) 
    		if (! typeAutomaton.isInitialState(state)) 
    	    	bonxai.addExpression(getExpression(state));
    	
    	Collection<Element> rootElements = schema.getElements();
    	for (Element rootElement: rootElements) {
    		bonxai.addRootElementName(rootElement.getName());
    	}
	}

	private Expression getExpression(State state) {
		AncestorPattern ancestorPattern = createAncestorPattern(state);
		ChildPattern childPattern = createChildPattern(state);

		Expression expression = new Expression();
		expression.setAncestorPattern(ancestorPattern);
		expression.setChildPattern(childPattern);
		Type type = typeAutomaton.getType(state);
		if ((type != null) && (!type.isAnonymous()) && (expression.getChildPattern().getElementPattern().getBonxaiType()==null))
				expression.addAnnotation(new Annotation("typename",this.typeAutomaton.getTypeName(state).getName()));
		return expression;
	}

	private void createDeclaration() {
		DefaultNamespace defaultNamespace;
		if (elementFormDefault == Qualification.qualified) {
			defaultNamespace = schema.getDefaultNamespace();
		} else {
			defaultNamespace = new DefaultNamespace("");
		}
		
		bonxai.setTargetNamespace(defaultNamespace);
		for (IdentifiedNamespace namespace: schema.getNamespaces()) {
			bonxai.addNamespace(namespace);
		}
	}
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
	private AncestorPattern createAncestorPattern(State state) {
    	//Create a dfa from typeAutomaton by choosing a final state.
    	ModifiableStateDFA dfa = new SparseNFA(typeAutomaton);
    	State dfaState = dfa.getState(typeAutomaton.getStateValue(state));
    	dfa.setFinalState(dfaState);
    	System.err.println("DFA: "+ dfa);

//    	Minimizer minimizer = new NFAMinimizer();
//    	minimizer.minimize(dfa);
//    	System.err.println("DFA after minimization: "+ dfa);
    	
    	// create regular expression from dfa
    	StateEliminationFactory regexFactory = new StateEliminationFactory();
    	Regex regex = regexFactory.create(dfa, false);
    	
    	// remove emptyset and epsilon
    	Normalizer normalizer = new EpsilonEmptyEliminator();
    	regex = normalizer.normalize(regex);
    	
    	System.err.println("Regex-Tree: "+ regex.getTree());
    	
    	// create particle from regex
    	Tree regexTree = regex.getTree();
    	Node root = regexTree.getRoot();
    	AncestorPattern ancestorPattern = convertTreeNode(root);
    	    	
    	System.err.println("AncestorPattern: " + ancestorPattern);
    	
    	return ancestorPattern;
    }

	private ChildPattern createChildPattern(State state) {
		Type type = typeAutomaton.getType(state);
		QualifiedName typename = typeAutomaton.getTypeName(state);
		ElementProperties elementProperties = typeAutomaton.getElementProperties(state);
		AttributePattern attributePattern = new AttributePattern();
		Particle particle = null;
		boolean mixed = false;
		if (type == null) {
			
		} else if (type instanceof ComplexType) {
			ComplexType complexType = (ComplexType) type;
			List<AttributeParticle> attributeParticles = complexType.getAttributes();
			attributePattern = convertAttributeParticles(attributeParticles);
			
			Content content = ((ComplexType) type).getContent();
			if (content instanceof ComplexContentType) {
				ComplexContentType complexContentType = (ComplexContentType) content;
				mixed = complexContentType.getMixed();
				particle = convertParticle(complexContentType.getParticle());
			} else if (content instanceof SimpleContentType) {
//				SimpleContentType simpleContentType = (SimpleContentType) content;
				particle = new EmptyPattern();
			} else if (content == null) {
				//TODO
			} else {
				throw new RuntimeException("Only complex content types allowed.");
			}
		
		} 
//		else {
//			throw new RuntimeException("Only complex types allowed.");
//		}
		ElementPattern elementPattern = null;
		if (particle == null)
			elementPattern = new ElementPattern(new BonxaiType(typename));
		else
			elementPattern = new ElementPattern(particle);
		elementPattern.setDefaultValue(elementProperties.getDefaultValue());
		elementPattern.setFixedValue(elementProperties.getFixedValue());
		elementPattern.setMissing(elementProperties.isNillable());
		ChildPattern childPattern = new ChildPattern(attributePattern, elementPattern, mixed);
		return childPattern;
	}

	private AttributePattern convertAttributeParticles(List<AttributeParticle> attributeParticles) {
		return attributeProcessor.convertAttributes(attributeParticles);
	}

	private Particle convertParticle(Particle particle) {
		return particleProcessor.convertParticle(particle);
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	private AncestorPattern convertTreeNode(Node<Object> node) {
		String key = node.getKey();
		if (key.equals(Regex.CONCAT_OPERATOR)) { //concatenation
			Vector<AncestorPattern> childParticles = new Vector<AncestorPattern>();
			for (Node child: node.getChildren()) {
				AncestorPattern childParticle = convertTreeNode(child);
				childParticles.add(childParticle);
			}
			return new SequenceExpression(childParticles);
		} else if (key.equals(Regex.ZERO_OR_MORE_OPERATOR)) { // kleene star
			return new CardinalityParticle(convertTreeNode(node.getChild(0)), 0);
		} else if (key.equals(Regex.UNION_OPERATOR)) { // or
			Vector<AncestorPattern> childParticles = new Vector<AncestorPattern>();
			for (Node child: node.getChildren()) {
				AncestorPattern childParticle = convertTreeNode(child);
				childParticles.add(childParticle);
			}
			return new OrExpression(childParticles);
		} else if (key.equals(Regex.EPSILON_SYMBOL)) {
			throw new RuntimeException("Epsilon no supported");
		} else if (key.equals(Regex.EMPTY_SYMBOL)) {
			throw new RuntimeException("Empty no supported");
		} else { // label
			String localName = key.substring(key.lastIndexOf("}") + 1);
			String namespaceURI = key.substring(1, key.lastIndexOf("}"));
			Namespace namespace = bonxai.getNamespaceByUri(namespaceURI);
			QualifiedName name = new QualifiedName(namespace, localName); 
			return new AncestorPatternElement(name);
		}
	}
}
