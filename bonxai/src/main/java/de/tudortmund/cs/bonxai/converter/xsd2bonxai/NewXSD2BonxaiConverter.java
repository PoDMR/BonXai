package de.tudortmund.cs.bonxai.converter.xsd2bonxai;

import gjb.flt.automata.converters.Minimizer;
import gjb.flt.automata.converters.NFAMinimizer;
import gjb.flt.automata.impl.sparse.ModifiableStateDFA;
import gjb.flt.automata.impl.sparse.SparseDFA;
import gjb.flt.automata.impl.sparse.State;
import gjb.flt.automata.impl.sparse.StateDFA;
import gjb.flt.automata.impl.sparse.Symbol;
import gjb.flt.regex.Regex;
import gjb.flt.regex.converters.EpsilonEmptyEliminator;
import gjb.flt.regex.converters.Normalizer;
import gjb.flt.regex.factories.StateEliminationFactory;
import gjb.util.tree.Node;
import gjb.util.tree.Tree;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.Vector;

import de.tudortmund.cs.bonxai.xsd.AttributeParticle;
import de.tudortmund.cs.bonxai.xsd.ComplexContentType;
import de.tudortmund.cs.bonxai.xsd.ComplexType;
import de.tudortmund.cs.bonxai.xsd.Content;
import de.tudortmund.cs.bonxai.xsd.SimpleContentType;
import de.tudortmund.cs.bonxai.xsd.Type;
import de.tudortmund.cs.bonxai.xsd.XSDSchema;
import de.tudortmund.cs.bonxai.xsd.XSDSchema.Qualification;
import de.tudortmund.cs.bonxai.bonxai.AncestorPattern;
import de.tudortmund.cs.bonxai.bonxai.AncestorPatternParticle;
import de.tudortmund.cs.bonxai.bonxai.AttributeGroupElement;
import de.tudortmund.cs.bonxai.bonxai.AttributePattern;
import de.tudortmund.cs.bonxai.bonxai.Bonxai;
import de.tudortmund.cs.bonxai.bonxai.CardinalityParticle;
import de.tudortmund.cs.bonxai.bonxai.ChildPattern;
import de.tudortmund.cs.bonxai.bonxai.ConstraintList;
import de.tudortmund.cs.bonxai.bonxai.DataTypeList;
import de.tudortmund.cs.bonxai.bonxai.Declaration;
import de.tudortmund.cs.bonxai.bonxai.ElementPattern;
import de.tudortmund.cs.bonxai.bonxai.Expression;
import de.tudortmund.cs.bonxai.bonxai.GrammarList;
import de.tudortmund.cs.bonxai.bonxai.GroupList;
import de.tudortmund.cs.bonxai.bonxai.ImportList;
import de.tudortmund.cs.bonxai.bonxai.OrExpression;
import de.tudortmund.cs.bonxai.bonxai.SequenceExpression;
import de.tudortmund.cs.bonxai.bonxai.SingleSlashPrefixElement;
import de.tudortmund.cs.bonxai.common.DefaultNamespace;
import de.tudortmund.cs.bonxai.common.EmptyPattern;
import de.tudortmund.cs.bonxai.common.IdentifiedNamespace;
import de.tudortmund.cs.bonxai.common.NamespaceList;
import de.tudortmund.cs.bonxai.common.Particle;
import de.tudortmund.cs.bonxai.common.ParticleContainer;
import de.tudortmund.cs.bonxai.common.SymbolTableFoundation;
import de.tudortmund.cs.bonxai.xsd.Element;
import de.tudortmund.cs.bonxai.typeautomaton.AnnotatedNFATypeAutomaton;
import de.tudortmund.cs.bonxai.typeautomaton.ElementProperties;
import de.tudortmund.cs.bonxai.typeautomaton.TypeAutomaton;
import de.tudortmund.cs.bonxai.typeautomaton.factories.XSDTypeAutomatonFactory;


/**
 * Main class to perform transformation from {@link de.tudortmund.cs.bonxai.xsd.XSDSchema} to {bonxai.Bonxai}.
 *
 * An instance of this class is used to transform an {@link de.tudortmund.cs.bonxai.xsd.XSDSchema},
 * generated by the XML XSDSchema parser to a valid {@link de.tudortmund.cs.bonxai.bonxai.Bonxai} instance. It
 * is meant to be used directly in the tool that will perform this conversion.
 *
 * The instance of this class, used for conversion, is configurable in its
 * behaviour. By default, it will use a standard set of {@link PreProcessor},
 * {@link ForeignSchemaFlattener}, {@link TypeAutomatonFactory} and {@link
 * BonxaiFactory}, each configured accurately to perform a standard conversion.
 *
 * Each object involved in the conversion can be replaced by a custom
 * configured object, using the corresponding methods (dependency injection).
 */
public class NewXSD2BonxaiConverter {
    /**
     * The schema to convert.
     */
    private XSDSchema schema;

    /**
     * TypeAutomaton used for conversion
     */
    private TypeAutomaton typeAutomaton;

	private SymbolTableFoundation<AttributeGroupElement> attributeGroupElements;
	
	private Qualification elementFormDefault;
    
    /**
     * Creates a new XSD2BonxaiConverter for the given schema.
     */
    public NewXSD2BonxaiConverter( ) {
    }
    
    public Bonxai convert(XSDSchema schema ) {
    	XSDTypeAutomatonFactory factory = new XSDTypeAutomatonFactory();
    	this.schema = schema;
    	this.elementFormDefault = schema.getElementFormDefault();

    	this.typeAutomaton = factory.createTypeAutomaton(schema);
    	
    	Bonxai bonxai = new Bonxai();
    	bonxai.setDeclaration(getDeclaration());
    	bonxai.setConstraintList(getConstraintList());
    	bonxai.setGroupList(getGroupList());
    	bonxai.setGrammarList(getGrammarList());
    	attributeGroupElements = bonxai.getAttributeGroupElementSymbolTable();
    	
    	return bonxai;
    }
    
    private GrammarList getGrammarList() {
    	GrammarList grammarList = new GrammarList();
    	for (State state: typeAutomaton.getStates()) 
    		if (! typeAutomaton.isInitialState(state)) 
    	    	grammarList.addExpression(getExpression(state));
    	
    	List<Element> rootElements = schema.getElements();
    	for (Element rootElement: rootElements) {
    		grammarList.addRootElementName(rootElement.getName());
    	}
    	
		return grammarList;
	}

	private Expression getExpression(State state) {
		AncestorPattern ancestorPattern = createAncestorPattern(state);
		ChildPattern childPattern = createChildPattern(state);

		Expression expression = new Expression();
		expression.setAncestorPattern(ancestorPattern);
		expression.setChildPattern(childPattern);
		return expression;
	}

	private GroupList getGroupList() {
		GroupList groupList = new GroupList();
		// TODO Auto-generated method stub
		return groupList;
	}

	private ConstraintList getConstraintList() {
		ConstraintList constraintList = new ConstraintList();
		// TODO Auto-generated method stub
		return constraintList;
	}

	private Declaration getDeclaration() {
		ImportList importList = new ImportList();
		DataTypeList dataTypeList = new DataTypeList();
		DefaultNamespace defaultNamespace;
		if (elementFormDefault == Qualification.qualified) {
			defaultNamespace = new DefaultNamespace(schema.getTargetNamespace());
		} else {
			defaultNamespace = new DefaultNamespace("");
		}
		NamespaceList namespaceList = new NamespaceList(defaultNamespace);
		for (IdentifiedNamespace namespace: schema.getNamespaceList().getIdentifiedNamespaces()) {
			namespaceList.addIdentifiedNamespace(namespace);
		}
		
    	// TODO add imports and dataTypes
		Declaration declaration = new Declaration(importList, dataTypeList, namespaceList);
		return declaration;
	}


    
    private AncestorPattern createAncestorPattern(State state) {
    	//Create a dfa from typeAutomaton by choosing a final state.
    	ModifiableStateDFA dfa = new SparseDFA(typeAutomaton);
    	State dfaState = dfa.getState(typeAutomaton.getStateValue(state));
    	dfa.setFinalState(dfaState);
    	System.err.println("DFA: "+ dfa);

//    	Minimizer minimizer = new NFAMinimizer();
//    	minimizer.minimize(dfa);
//    	System.err.println("DFA after minimization: "+ dfa);
    	
    	// create regular expression from dfa
    	StateEliminationFactory regexFactory = new StateEliminationFactory();
    	Regex regex = regexFactory.create(dfa, false);
    	
    	// remove emptyset and epsilon
    	Normalizer normalizer = new EpsilonEmptyEliminator();
    	regex = normalizer.normalize(regex);
    	
    	System.err.println("Regex-Tree: "+ regex.getTree());
    	
    	// create particle from regex
    	Tree regexTree = regex.getTree();
    	Node root = regexTree.getRoot();
    	AncestorPatternParticle particle = convertTreeNode(root);
    	
    	AncestorPattern ancestorPattern = new AncestorPattern(particle);
    	
    	System.err.println("AncestorPattern: " + ancestorPattern);
    	
    	return ancestorPattern;
    }

	private ChildPattern createChildPattern(State state) {
		Type type = typeAutomaton.getType(state).getReference();
		ElementProperties elementProperties = typeAutomaton.getElementProperties(state);
		AttributePattern attributePattern = new AttributePattern();
		Particle particle = null;
		boolean mixed = false;
		
		if (type instanceof ComplexType) {
			ComplexType complexType = (ComplexType) type;
			List<AttributeParticle> attributeParticles = complexType.getAttributes();
			attributePattern = convertAttributeParticles(attributeParticles);
			
			Content content = ((ComplexType) type).getContent();
			if (content instanceof ComplexContentType) {
				ComplexContentType complexContentType = (ComplexContentType) content;
				mixed = complexContentType.getMixed();
				particle = convertParticle(complexContentType.getParticle());
			} else if (content instanceof SimpleContentType) {
				SimpleContentType simpleContentType = (SimpleContentType) content;
				particle = new EmptyPattern();
			} else if (content == null) {
				//TODO
			} else {
				throw new RuntimeException("Only complex content types allowed.");
			}
		
		} else {
			throw new RuntimeException("Only complex types allowed.");
		}
		ElementPattern elementPattern = null;
		if (particle != null) { 
			elementPattern = new ElementPattern(particle);
			elementPattern.setDefault(elementProperties.getDefaultValue());
			elementPattern.setFixed(elementProperties.getFixedValue());
			elementPattern.setMissing(elementProperties.isNillable());
			elementPattern.setMixed(mixed);
		}
		ChildPattern childPattern = new ChildPattern(attributePattern, elementPattern);
		return childPattern;
	}

	private AttributePattern convertAttributeParticles(List<AttributeParticle> attributeParticles) {
		AttributeProcessor attributeProcessor = new AttributeProcessor(attributeGroupElements);
		return attributeProcessor.convertAttributes(attributeParticles);
	}

	private Particle convertParticle(Particle particle) {
		ParticleProcessor particleProcessor = new ParticleProcessor(null, elementFormDefault);
		return particleProcessor.convertParticle(particle);
	}

	private AncestorPatternParticle convertTreeNode(Node node) {
		String key = node.getKey();
		if (key.equals(Regex.CONCAT_OPERATOR)) { //concatenation
			Vector<AncestorPatternParticle> childParticles = new Vector<AncestorPatternParticle>();
			for (Node child: node.getChildren()) {
				AncestorPatternParticle childParticle = convertTreeNode(child);
				childParticles.add(childParticle);
			}
			return new SequenceExpression(childParticles);
		} else if (key.equals(Regex.ZERO_OR_MORE_OPERATOR)) { // kleene star
			return new CardinalityParticle(convertTreeNode(node.getChild(0)), 0);
		} else if (key.equals(Regex.UNION_OPERATOR)) { // or
			Vector<AncestorPatternParticle> childParticles = new Vector<AncestorPatternParticle>();
			for (Node child: node.getChildren()) {
				AncestorPatternParticle childParticle = convertTreeNode(child);
				childParticles.add(childParticle);
			}
			return new OrExpression(childParticles);
		} else if (key.equals(Regex.EPSILON_SYMBOL)) {
			throw new RuntimeException("Epsilon no supported");
		} else if (key.equals(Regex.EMPTY_SYMBOL)) {
			throw new RuntimeException("Empty no supported");
		} else { // label //TODO other operators
			String name = key.substring(key.lastIndexOf("}") + 1);
			String namespace = key.substring(1, key.lastIndexOf("}"));
			return new SingleSlashPrefixElement(namespace, name);
		}
	}


    
}
