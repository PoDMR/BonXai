/* Generated By:JavaCC: Do not edit this line. BonxaiVisitor.java Version 4.2 */

package de.tudortmund.cs.bonxai.bonxai.parser;

import de.tudortmund.cs.bonxai.bonxai.*;
import de.tudortmund.cs.bonxai.bonxai.Annotation;
import de.tudortmund.cs.bonxai.bonxai.Element;
import de.tudortmund.cs.bonxai.common.*;
import de.tudortmund.cs.bonxai.utils.ContentModelValidator;
import de.tudortmund.cs.bonxai.utils.exceptions.RecursiveContentModelException;
import de.tudortmund.cs.bonxai.utils.exceptions.UPAViolationException;

import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Visitor implements bonXaiTreeVisitor {

	private Bonxai bonxai = new Bonxai();
	private Boolean contentModelValidation = false;


	public Visitor(Bonxai bonxai) {
		this.bonxai = bonxai;
	}


	public Visitor(Bonxai bonxai, Boolean contentModelValidation) {
		this.bonxai = bonxai;
		this.contentModelValidation = contentModelValidation;
	}

	public Bonxai visit(SimpleNode node, Object data) {
		return this.visit((ASTbonXai) node, data);
	}


	public Bonxai visit(ASTbonXai node, Object data) {
		Declaration declaration = new Declaration(new ImportList(), new DataTypeList(), new NamespaceList(new DefaultNamespace("")));
		bonxai.setDeclaration(declaration);
		
		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			if (node.jjtGetChild(i).getNodeType().equals("declaration")) {
				ASTDecl subnode = (ASTDecl) node.jjtGetChild(i);
				this.visit(subnode, declaration);
			} else if (node.jjtGetChild(i).getNodeType().equals("GroupBlock")) {
				ASTGroupBlock subnode = (ASTGroupBlock) node.jjtGetChild(i);
				bonxai.setGroupList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("Block")) {
				ASTBlock subnode = (ASTBlock) node.jjtGetChild(i);
				bonxai.setGrammarList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("ConstraintBlock")) {
				ASTConstraintBlock subnode = (ASTConstraintBlock) node.jjtGetChild(i);
				bonxai.setConstraintList(this.visit(subnode, null));
			}
		}
		try {
			bonxai.getAttributeGroupElementSymbolTable().checkReferences();
			bonxai.getGroupSymbolTable().checkReferences();
			return bonxai;
		} catch (SymbolNotResolvableException e) {
			throw new RuntimeException(e);
		}
	}

	public Object visit(ASTDecl node, Object data) {
		Declaration declaration = (Declaration) data;
		
		NamespaceList namespaceList = declaration.getNamespaceList();
		ImportList importList = declaration.getImportList();
		DataTypeList dataTypeList = declaration.getDataTypeList();

		if (node.getNodeChoice().equals("default")) {
			namespaceList.getDefaultNamespace().setUri(node.getUri());
		} 

		if (node.getNodeChoice().equals("namespace")) {
			IdentifiedNamespace identifiedNamespace = new IdentifiedNamespace(node.getIdentifier(), node.getUri());
			namespaceList.addIdentifiedNamespace(identifiedNamespace);
		}

		if (node.getNodeChoice().equals("import")) {
			Import myImport;

			if (node.getUrl().equals("")) {
				myImport = new Import(node.getUri());
			} else {
				myImport = new Import(node.getUri(), node.getUrl());
			}
			importList.addImport( myImport);
		}

		if (node.getNodeChoice().equals("datatypes")) {
			DataType dataType = new DataType(node.getIdentifier(), node.getUrl());
			dataTypeList.addDataType(dataType);
		}

		return null;
	}

	public ConstraintList visit(ASTConstraintBlock node, Object data) {
		ConstraintList constraintList = new ConstraintList();
		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			ASTConstraint subnode = (ASTConstraint) node.jjtGetChild(i);
			constraintList.addConstraint(this.visit(subnode, null));
		}

		return constraintList;
	}

	public Constraint visit(ASTConstraint node, Object data) {
		Constraint constraint;
		if (node.jjtGetChild(0).getNodeType().equals("UniqueConstraint")) {
			ASTUniqueConstraint subnode = (ASTUniqueConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		} else if (node.jjtGetChild(0).getNodeType().equals("KeyConstraint")) {
			ASTKeyConstraint subnode = (ASTKeyConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		} else {
			ASTKeyRefConstraint subnode = (ASTKeyRefConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		}

		return constraint;
	}

	public UniqueConstraint visit(ASTUniqueConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		UniqueConstraint uniqueConstraint =
			new UniqueConstraint(this.visit(subnode, null),
					node.getSelector(), node.getFields());
		return uniqueConstraint;
	}

	public KeyConstraint visit(ASTKeyConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		KeyConstraint keyConstraint =
			new KeyConstraint(node.getName(), this.visit(subnode, null),
					node.getSelector(), node.getFields());
		return keyConstraint;
	}

	public KeyRefConstraint visit(ASTKeyRefConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		KeyRefConstraint keyRefConstraint =
			new KeyRefConstraint(node.getName(),
					this.visit(subnode, null), node.getSelector(), node.getFields());
		return keyRefConstraint;
	}

	public GroupList visit(ASTGroupBlock node, Object data) {

		GroupList groupList = new GroupList();
		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			ASTGroupRule subnode = (ASTGroupRule) node.jjtGetChild(i);
			groupList.addGroupElement(this.visit(subnode, null));
		}
		return groupList;
	}

	public GroupElement visit(ASTGroupRule node, Object data) {
		if (node.getNodeChoice().equals("group")) {
			ASTRegex subnode = (ASTRegex) node.jjtGetChild(0);

			Particle particle = this.visit(subnode, null);
			ParticleContainer particleContainer = new SequencePattern();
			particleContainer.addParticle(particle);
			ElementGroupElement elementGroupElement =
				new ElementGroupElement(node.getName(), particleContainer);
			bonxai.getGroupSymbolTable().updateOrCreateReference(node.getName(), elementGroupElement);
			return elementGroupElement;
		} else {
			ASTAttributePattern subnode = (ASTAttributePattern) node.jjtGetChild(0);
			
			AttributePattern attributePattern = this.visit(subnode, null);
			AttributeGroupElement attributeGroupElement =
				new AttributeGroupElement(node.getName(), attributePattern);
			bonxai.getAttributeGroupElementSymbolTable().updateOrCreateReference(node.getName(), attributeGroupElement);
			      return attributeGroupElement;
		}
	}

	public Expression visit(ASTExpr node, Object data) {
		// to be extended
		Expression expression = new Expression();
		AncestorPattern ancestorPattern;

		ChildPattern childPattern;

		if (node.jjtGetNumChildren() == 3) {
			ASTAnnotations annotationSubnode = (ASTAnnotations) node.jjtGetChild(0);
			ASTAPattern aPatternSubnode = (ASTAPattern) node.jjtGetChild(1);
			ASTCPattern cPatternSubnode = (ASTCPattern) node.jjtGetChild(2);
			expression =
				this.visit(annotationSubnode, expression);
			ancestorPattern =
				this.visit(aPatternSubnode, null);
			childPattern =
				this.visit(cPatternSubnode, null);
		} else {
			ASTAPattern aPatternSubnode = (ASTAPattern) node.jjtGetChild(0);
			ASTCPattern cPatternSubnode = (ASTCPattern) node.jjtGetChild(1);
			ancestorPattern =
				this.visit(aPatternSubnode, null);
			childPattern =
				this.visit(cPatternSubnode, null);
		}

		expression.setAncestorPattern(ancestorPattern);
		expression.setChildPattern(childPattern);
		return expression;
	}

	public Expression visit(ASTAnnotations node, Object data) {
		Expression expression = (Expression) data;
		for (int i = 0; i <
		node.jjtGetNumChildren(); i++) {
			ASTAnnotation subnode = (ASTAnnotation) node.jjtGetChild(i);
			expression.addAnnotation(this.visit(subnode, null));
		}

		return expression;
	}

	public AncestorPattern visit(ASTAPattern node, Object data) {
		AncestorPattern ancestorPattern = new AncestorPattern(null);
		if (node.getNodeChoice().equals("full")) {
			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);
			AncestorPatternParticle particle = this.visit(subnode, null);
			ancestorPattern = new AncestorPattern(particle);
		}
//		else {
//
//			if (node.getNodeChoice().equals("simple_full")) {
//
//				ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
//				ASTFullAPattern fullnode = (ASTFullAPattern) node.jjtGetChild(1);
//				
//
//			}
//			else {
//
//				ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
//				
//			}
//
//		}

		return ancestorPattern;
	}

	public AncestorPatternParticle visit(ASTSimpleAPattern node, Object data) {
		AncestorPatternParticle apattern;

		if (node.getName() != "") {
			String name =  extractName(node.getName());
			String namespace = extractIdentifier(node.getName());

			apattern = new DoubleSlashPrefixElement(namespace, name);

			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);
		}
		else {
			ASTSimpleAPatternOr subnode = (ASTSimpleAPatternOr) node.jjtGetChild(0);

			Vector<AncestorPatternParticle> orExpressionContent = new Vector<AncestorPatternParticle>();
			orExpressionContent.add(this.visit(subnode, null));

			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;
		}
		return apattern;
	}

	public AncestorPatternParticle visit(ASTFullAPatternOr node, Object data) {
		if (node.jjtGetNumChildren() == 1) {
			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			Vector<AncestorPatternParticle> orExpressionContent = new Vector<AncestorPatternParticle>();
			for (Node subnode: node.children) {
				ASTFullAPattern astFullAPattern = (ASTFullAPattern) subnode;
				orExpressionContent.add(this.visit(astFullAPattern, null));
			}
			
			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;
		}
	}

	public AncestorPatternParticle visit(
			ASTSimpleAPatternOr  node, Object data) {
		if (node.jjtGetNumChildren() == 1) {
			ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			ASTSimpleAPattern subnodeOne = (ASTSimpleAPattern) node.jjtGetChild(0);
			ASTSimpleAPattern subnodeTwo = (ASTSimpleAPattern) node.jjtGetChild(1);
			Vector<AncestorPatternParticle> orExpressionContent =
				new Vector<AncestorPatternParticle>();
			orExpressionContent.add(this.visit(subnodeOne, null));
			orExpressionContent.add(this.visit(subnodeTwo, null));
			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;
		}
	}

	public AncestorPatternParticle visit(ASTFullAPattern node, Object data) {
		AncestorPatternParticle content;
		String namespace;
		String name;

		boolean sequence = node.getSequence();

		if (node.getNodeChoice().equals("separator")) {
			ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
			String bonxainame = subnode.getName();
			
			namespace = this.extractIdentifier(bonxainame);
			name = this.extractName(bonxainame);
	
			if (node.getSeparator())
				content = new DoubleSlashPrefixElement(namespace, name);
			else 
				content = new SingleSlashPrefixElement(namespace, name);
		} else {
			ASTFullAPatternOr subnode = (ASTFullAPatternOr) node.jjtGetChild(0);
			AncestorPatternParticle childContent = this.visit(subnode, null);

			if (! node.getOperator().isEmpty()) {
				Integer min = 1;
				Integer max = 1;
				if (node.getOperator().equals("*")) {
					min = 0;
					max = null;
				} else if (node.getOperator().equals("+")) {
					max = null;
				} else if (node.getOperator().equals("?")) {
					min = 0;
				}

				content = new CardinalityParticle(childContent, min, max);
			} else {
				content = childContent;
			}
		}

		if (sequence) {
			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(1);

			SequenceExpression sequenceExpression = new SequenceExpression();
			sequenceExpression.addChild(content);
			
			while (sequence) {
				sequence = subnode.getSequence();
				subnode.setSequence(false);
				content = this.visit(subnode, null);
				sequenceExpression.addChild(content);
			} 
			
			content = sequenceExpression;
		}
		return content;
	}

	public Annotation visit(ASTAnnotation node, Object data) {
		String name="";
		String value="";

		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			if (node.jjtGetChild(i).getNodeType().equals("AnnotationName")) {
				ASTAnnotationName subnode = (ASTAnnotationName) node.jjtGetChild(0);
				name =  subnode.getName();
			}

			if (node.jjtGetChild(i).getNodeType().equals("AnnotationValue")) {
				ASTAnnotationValue subnode = (ASTAnnotationValue) node.jjtGetChild(0);
				value =  subnode.getName();
			}
		}

		Annotation annotation = new Annotation( name, value);

		return annotation;
	}

	public Particle visit( ASTRegex node, Object data) {
		Particle particle = null;

		if (node.getNodeChoice().equals("regex")) {
			// (regex)
			ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
			particle = this.visit(nextRegex, null);
		} else if (node.getNodeChoice().equals("namedtype")) {
			// (NamedType)
			ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
			particle = this.visit(namedType, null);
		}
		
		CountingPattern countingPattern = null;

		if (node.getOperator().equals("*"))
			countingPattern = new CountingPattern(particle, 0, null);
		else if (node.getOperator().equals("+"))
			countingPattern = new CountingPattern(particle, 1, null);
		else if (node.getOperator().equals("?"))
			countingPattern = new CountingPattern(particle, 0, 1);
		else if (node.getNumberBefore() > 0 &&  node.getNumberAfter() > 0)
			countingPattern = new CountingPattern(particle, node.getNumberBefore(), node.getNumberAfter());
		else if (node.getNumberBefore() > 0 && node.getSecondOperator().equals("*"))
			countingPattern = new CountingPattern(particle, node.getNumberBefore(), null);
	
		if (countingPattern != null)
			particle = countingPattern;

		boolean concatenation = node.isConcatenation();
		boolean disjunction = node.isDisjunction();
		
		// concatenation has a higher priority than or
		if (concatenation) {
			SequencePattern sequencePattern = new SequencePattern();
			sequencePattern.addParticle(particle);
			
			while (concatenation) {
				node = (ASTRegex) node.jjtGetChild(1);
				concatenation = node.isConcatenation();
				disjunction = node.isDisjunction();
				node.setConcatenation(false);
				node.setDisjunction(false);
				
				particle = this.visit(node, null);
				sequencePattern.addParticle(particle);
			}
		
			particle = sequencePattern;
		} 
		
		if (disjunction) {
			ChoicePattern choicePattern = new ChoicePattern();
			choicePattern.addParticle(particle);
			
			while (disjunction) {
				node = (ASTRegex) node.jjtGetChild(1);
				disjunction = node.isDisjunction();
				node.setDisjunction(false);

				particle = this.visit(node, null);
				choicePattern.addParticle(particle);
			}

			particle = choicePattern;
		}

		return particle;
	}

	public Element visit(ASTNamedType node, Object data) {
		if (node.getNodeChoice().equals("element")) {
			de.tudortmund.cs.bonxai.bonxai.Element content;

			String name = extractName(node.getName());
			String namespace = extractIdentifier(node.getName());

			if (node.jjtGetNumChildren() == 0) {
				content = new de.tudortmund.cs.bonxai.bonxai.Element(namespace, name);
			} else {
				ASTBonxaiType subnode = (ASTBonxaiType) node.jjtGetChild(0);
				BonxaiType bonxaiType = this.visit(subnode, null);
				content =
					new de.tudortmund.cs.bonxai.bonxai.Element(
							namespace, name, bonxaiType, subnode.getMissing());
				if (subnode.getDefault()) {
					content.setDefault(subnode.getName());
				}

				if (subnode.getFixed()) {
					content.setFixed(subnode.getName());
				}
			}
			return content;
		}

		if (node.getNodeChoice().equals("group")) {
			GroupRef groupRef = new GroupRef(
					bonxai.getGroupSymbolTable().getReference(node.getName()));
		}

		if (node.getNodeChoice().equals("foreign")) {
			String namespace ="";
			// Wie namespaceListe Vector in String ?!  String namespace = node.getNameSpaceList();
			AnyPattern anyPattern;
			Integer max;
			if (node.getForeign().equals("lax")) {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Lax, namespace);
			} else if (node.getForeign().equals("skip")) {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Skip, namespace);
			} else {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Strict, namespace);
			}

			if (node.getNumberBefore() >0 && node.getNumberAfter() ==0) {

				CountingPattern countingPattern =
					new CountingPattern(node.getNumberBefore(), null);
				countingPattern.addParticle(anyPattern);
			}

			if (node.getNumberBefore() >0 && node.getNumberAfter() >0) {
				CountingPattern countingPattern =
					new CountingPattern(node.getNumberBefore(), node.getNumberAfter());
				countingPattern.addParticle(anyPattern);
			}
		}
		return null;
	}

	public Particle visit(ASTAll node, Object data) {
		if (node.jjtGetNumChildren() == 1) {
			ASTNamedType subnode = (ASTNamedType) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			AllPattern allPattern = new AllPattern();
			for (int i = 0; i < node.jjtGetNumChildren(); i++) {
				ASTNamedType subnode = (ASTNamedType) node.jjtGetChild(i);
				allPattern.addParticle(this.visit(subnode, null));
			}
			return allPattern;
		}
	}

	@Override
	public Object visit(ASTConstraintSelector node, Object data) {
		// implementation not necessary
		return null;
	}

	@Override
	public Object visit(ASTConstraintFields node, Object data) {
		// implementation not necessary
		return null;
	}


	@Override
	public GrammarList visit(ASTBlock node, Object data) {
		GrammarList grammarList = new GrammarList();
		for (Node subnode: node.children) {
			if (subnode.getNodeType().equals("RootElements")) {
				this.visit((ASTRootElements) subnode, grammarList);
			} else if (subnode.getNodeType().equals("Expr")) {
				grammarList.addExpression(this.visit((ASTExpr) subnode, null));
			}
		}
		
		return grammarList;
	}


	@Override
	public Object visit(ASTAnnotationName node, Object data) {
		return null;
	}

	@Override
	public ChildPattern visit(ASTCPattern node, Object data) {
        AttributePattern attributePattern;
        ASTElementPattern elementSubnode;

        if (node.jjtGetNumChildren() == 1) {
            attributePattern = new AttributePattern();
            elementSubnode =
                    (ASTElementPattern) node.jjtGetChild(0);
        } else {
            ASTAttributePattern subnode = (ASTAttributePattern) node.jjtGetChild(0);
            attributePattern =
                    this.visit(subnode, null);
            elementSubnode =
                    (ASTElementPattern) node.jjtGetChild(1);
        }

        ElementPattern elementPattern = this.visit(elementSubnode, null);
        ChildPattern content = new ChildPattern(attributePattern, elementPattern);
        return content;
	}


	@Override
	public ElementPattern visit(ASTElementPattern node, Object data) {
		 ElementPattern elementPattern;
	        if (node.getEmpty()) {
	            elementPattern = null;
	        } else {
	            if (node.jjtGetChild(0).getNodeType().equals("BonxaiType")) {
	                ASTBonxaiType subnode = (ASTBonxaiType) node.jjtGetChild(0);
	                elementPattern =
	                        new ElementPattern(this.visit(subnode, null), node.getMissing());
	                if (subnode.getDefault()) {
	                    elementPattern.setDefault(subnode.getName());
	                }

	                if (subnode.getFixed()) {
	                    elementPattern.setFixed(subnode.getName());
	                }

	            } else {
	                ASTMixedRegex subnode = (ASTMixedRegex) node.jjtGetChild(0);
	                elementPattern =
	                        new ElementPattern(this.visit(subnode, null), node.getMissing());
	            }

	        }
	        return elementPattern;
	}

	@Override
	public Particle visit(ASTMixedRegex node, Object data) {
		 Particle content;
	        if (node.jjtGetChild(0).getNodeType().equals("All")) {
	            ASTAll subnode = (ASTAll) node.jjtGetChild(0);
	            content =
	                    this.visit(subnode, null);
	        } else {
	            ASTRegex subnode = (ASTRegex) node.jjtGetChild(0);
	            content =
	                    this.visit(subnode, null);
	        }
	        if (contentModelValidation) {
	            try {
	                ContentModelValidator validator = new ContentModelValidator(content);
	                validator.checkDeterminism();
	            } catch (UPAViolationException ex) {
	                Logger.getLogger(Visitor.class.getName()).log(Level.SEVERE, null, ex);
	            } catch (RecursiveContentModelException ex) {
	                Logger.getLogger(Visitor.class.getName()).log(Level.SEVERE, null, ex);
	            }
	        }
	        return content;
	}

	@Override
	public AttributePattern visit(ASTAttributePattern node, Object data) {
		 AttributePattern attributePattern = new AttributePattern();
		 
		 ProcessContentsInstruction instruction = null;
		 if (node.getForeign().equals("lax")) {
			 instruction = ProcessContentsInstruction.Lax;
		 } else if (node.getForeign().equals("strict")) {
			 instruction = ProcessContentsInstruction.Strict;
		 } else if (node.getForeign().equals("skip")) {
			 instruction = ProcessContentsInstruction.Skip;
		 }

		 // Frage: String setzen, aber DS liefert eine Liste!! so eher nicht
	        AnyAttribute anyAttribute = new AnyAttribute(instruction, node.getNamespaceList().toString());
		 
	        
	        if (node.getAttributeList().size()>1) {
	        
	        
	        }
		 
		 Vector<AttributeListElement> attributeList = new Vector<AttributeListElement>();
		 
		 
		 for(int i=0; i < node.getAttributeList().size(); i++) {
			
			 
			 AttributeGroupReference attributeGroupReference =
	                new AttributeGroupReference(
	                bonxai.getAttributeGroupElementSymbolTable().getReference(node.getAttributeList().get(i).toString()));
			 
			 Attribute attribute;
		        String name = extractName( node.getAttributeList().get(i).toString());
		        String namespace = extractIdentifier( node.getAttributeList().get(i).toString());
		        if (node.jjtGetNumChildren() == 0) {
		        	// gibt keinen type ?! name eher falsch
		            String typeNamespace = extractIdentifier(node.getAttributeList().get(i).toString());
		            String type = extractName(node.getAttributeList().get(i).toString());
		            BonxaiType bonxaiType = new BonxaiType(namespace, type);
		            attribute = new Attribute(namespace, name, bonxaiType);
		        } else {
		            ASTAttrBonxaiType subnode = (ASTAttrBonxaiType) node.jjtGetChild(0);
		            BonxaiType bonxaiType = this.visit(subnode, null);
		            attribute = new Attribute(namespace, name, bonxaiType);
		            if (subnode.getDeafult()) {
		                attribute.setDefault(subnode.getName());
		            }
		            if (subnode.getFixed()) {
		                attribute.setFixed(subnode.getName());
		            }
		        }

			 attributePattern.addAttribute(attribute);
		 }
		 
		 attributePattern.setAttributeList(attributeList);
		 
		 return attributePattern;
	}

	@Override
	public Object visit(ASTAttributeList node, Object data) {
		return null;
	}

	@Override
	public Object visit(ASTNameSpaceList node, Object data) {
		return null;
	}

	@Override
	public Object visit(ASTForeign node, Object data) {
		return null;
	}

	@Override
	public BonxaiType visit(ASTBonxaiType node, Object data) {
		String namespace = extractIdentifier(node.getType());
        String type = extractName(node.getType());
        BonxaiType bonxaiType = new BonxaiType(namespace, type);
        return bonxaiType;
	}

	@Override
	public BonxaiType visit(ASTAttrBonxaiType node, Object data) {
        String namespace = extractIdentifier(node.getType());
        String type = extractName(node.getType());
        BonxaiType bonxaiType = new BonxaiType(namespace, type);
        return bonxaiType;
	}
	
    public String extractName(
            String nameWithPossibleIdentifier) {
        //Initially namespace is the default namespace
        String namespace = bonxai.getDeclaration().getNamespaceList().getDefaultNamespace().getUri();
        String name = nameWithPossibleIdentifier;
        String nameWithoutIdentifierAndColon = "";
        String possibleIdentifier = "";
        //BEGIN: Cropping construction for Identifier extraction
        for (int i = 0; i <
                nameWithPossibleIdentifier.length() - 1; i++) {
            if ((i > 0) && nameWithPossibleIdentifier.substring(i, i + 1).equals(":")) {
                possibleIdentifier = nameWithPossibleIdentifier.substring(0, i);
                nameWithoutIdentifierAndColon =
                        nameWithPossibleIdentifier.substring(i + 1, nameWithPossibleIdentifier.length());
            }

        }

        if (possibleIdentifier.isEmpty()) {
            if (name.startsWith(":")) {
                //name stays name
                }
        }

        if (possibleIdentifier.isEmpty()) {
            if (name.endsWith(":")) {
                //name stays name
                }
        }

        //END: Cropping construction for Identifier extraction
        if (possibleIdentifier.isEmpty()) {
            //name stays name
            } else {
            if (bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri() != null) {
                namespace = bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri();
                name =
                        nameWithoutIdentifierAndColon;
            }

        }
        return name;
    }

    public String extractIdentifier(
            String nameWithPossibleIdentifier) {
        //Initially namespace is the default namespace
        String namespace = bonxai.getDeclaration().getNamespaceList().getDefaultNamespace().getUri();
        String name = nameWithPossibleIdentifier;
        String nameWithoutIdentifierAndColon = "";
        String possibleIdentifier = "";
        //BEGIN: Cropping construction for Identifier extraction
        for (int i = 0; i <
                nameWithPossibleIdentifier.length() - 1; i++) {
            if ((i > 0) && nameWithPossibleIdentifier.substring(i, i + 1).equals(":")) {
                possibleIdentifier = nameWithPossibleIdentifier.substring(0, i);
                nameWithoutIdentifierAndColon =
                        nameWithPossibleIdentifier.substring(i + 1, nameWithPossibleIdentifier.length() - 1);
            }

        }

        if (possibleIdentifier.isEmpty()) {
            if (name.startsWith(":")) {
                //name stays name
                }
        }

        if (possibleIdentifier.isEmpty()) {
            if (name.endsWith(":")) {
                //name stays name
            }
        }

        //END: Cropping construction for Identifier extraction
        if (possibleIdentifier.isEmpty()) {
        	//name stays name
        } else {
        	if (bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri() != null) {
        		namespace = bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri();
        		name = nameWithoutIdentifierAndColon;
        	}
        }
        return namespace;
    }

	@Override
	public Object visit(ASTAnnotationValue node, Object data) {
		return null;
	}

	@Override
	public Object visit(ASTRootElements node, Object data) {
		GrammarList grammarList = (GrammarList) data;
		
		for (String rootElement: node.getRootElementNames()) {
			String name = this.extractName(rootElement);
			String namespace = this.extractIdentifier(rootElement);
			
			grammarList.addRootElementName("{"+namespace+"}"+name);
		}
		
		return null;
	}
}
/* JavaCC - OriginalChecksum=61392cb8ba6d017f5680f7409376633d (do not edit this line) */
