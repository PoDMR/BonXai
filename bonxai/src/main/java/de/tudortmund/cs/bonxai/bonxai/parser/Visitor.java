/* Generated By:JavaCC: Do not edit this line. BonxaiVisitor.java Version 4.2 */

package de.tudortmund.cs.bonxai.bonxai.parser;

import de.tudortmund.cs.bonxai.bonxai.*;
import de.tudortmund.cs.bonxai.bonxai.Annotation;
import de.tudortmund.cs.bonxai.bonxai.Element;
import de.tudortmund.cs.bonxai.common.*;
import de.tudortmund.cs.bonxai.utils.ContentModelValidator;
import de.tudortmund.cs.bonxai.utils.exceptions.RecursiveContentModelException;
import de.tudortmund.cs.bonxai.utils.exceptions.UPAViolationException;

import java.util.Vector;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Visitor implements bonXaiTreeVisitor {

	private Bonxai bonxai = new Bonxai();
	private Boolean contentModelValidation = false;


	public Visitor(Bonxai bonxai) {
		this.bonxai = bonxai;
	}


	public Visitor(Bonxai bonxai, Boolean contentModelValidation) {
		this.bonxai = bonxai;
		this.contentModelValidation = contentModelValidation;
	}

	public Bonxai visit(SimpleNode node, Object data) {
		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			if (node.jjtGetChild(i).getNodeType().equals("declaration")) {
				ASTDecl subnode = (ASTDecl) node.jjtGetChild(i);
				bonxai.setDeclaration(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("GroupBlock")) {
				ASTGroupBlock subnode = (ASTGroupBlock) node.jjtGetChild(i);
				bonxai.setGroupList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("Block")) {
				ASTBlock subnode = (ASTBlock) node.jjtGetChild(i);
				bonxai.setGrammarList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("ConstraintBlock")) {
				ASTConstraintBlock subnode = (ASTConstraintBlock) node.jjtGetChild(i);
				bonxai.setConstraintList(this.visit(subnode, null));
			}

		}
		try {
			bonxai.getAttributeGroupElementSymbolTable().checkReferences();
			bonxai.getGroupSymbolTable().checkReferences();
			return bonxai;
		} catch (SymbolNotResolvableException e) {
			System.out.println(e);
		}
		return bonxai;
	}


	public Bonxai visit(ASTbonXai node, Object data) {

		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			if (node.jjtGetChild(i).getNodeType().equals("declaration")) {
				ASTDecl subnode = (ASTDecl) node.jjtGetChild(i);
				bonxai.setDeclaration(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("GroupBlock")) {
				ASTGroupBlock subnode = (ASTGroupBlock) node.jjtGetChild(i);
				bonxai.setGroupList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("Block")) {
				ASTBlock subnode = (ASTBlock) node.jjtGetChild(i);
				bonxai.setGrammarList(this.visit(subnode, null));
			} else if (node.jjtGetChild(i).getNodeType().equals("ConstraintBlock")) {
				ASTConstraintBlock subnode = (ASTConstraintBlock) node.jjtGetChild(i);
				bonxai.setConstraintList(this.visit(subnode, null));
			}

		}
		try {
			bonxai.getAttributeGroupElementSymbolTable().checkReferences();
			bonxai.getGroupSymbolTable().checkReferences();
			return bonxai;
		} catch (SymbolNotResolvableException e) {
			System.out.println(e);
		}
		return bonxai;
	}


	public Declaration visit(ASTDecl node, Object data) {
	
		NamespaceList namespaceList =
			new NamespaceList(new DefaultNamespace(""));
		ImportList importList = new ImportList();
		DataTypeList dataTypeList = new DataTypeList();

	
		if (node.getNodeChoice().equals("default")) {
		namespaceList.getDefaultNamespace().setUri(node.getUri());
		} 
			
		
		if (node.getNodeChoice().equals("namespace")) {
			
		IdentifiedNamespace identifiedNamespace = new IdentifiedNamespace(node.getIdentifier(), node.getUri());
		namespaceList.addIdentifiedNamespace(identifiedNamespace);
		
		}
		
		
		if (node.getNodeChoice().equals("import")) {
			
			 Import myImport;
			
			 if (node.getUrl().equals("")) {
		            myImport = new Import(node.getUri());
		        } else {
		            myImport = new Import(node.getUri(), node.getUrl());
		        }
			
			
			 importList.addImport( myImport);
			
			}
		
		
		if (node.getNodeChoice().equals("datatypes")) {
			
			DataType dataType = new DataType(node.getIdentifier(), node.getUrl());
			dataTypeList.addDataType(dataType);
			
			}
		


		Declaration declaration = new Declaration(importList, dataTypeList, namespaceList);
		return declaration;
	}


	public ConstraintList visit(ASTConstraintBlock node, Object data) {

		ConstraintList constraintList = new ConstraintList();
		for (int i = 0; i <
		node.jjtGetNumChildren(); i++) {
			ASTConstraint subnode = (ASTConstraint) node.jjtGetChild(i);
			constraintList.addConstraint(this.visit(subnode, null));
		}

		return constraintList;


	}



	public Constraint visit(ASTConstraint node, Object data) {

		Constraint constraint;
		if (node.jjtGetChild(0).getNodeType().equals("UniqueConstraint")) {
			ASTUniqueConstraint subnode = (ASTUniqueConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		} else if (node.jjtGetChild(0).getNodeType().equals("KeyConstraint")) {
			ASTKeyConstraint subnode = (ASTKeyConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		} else {
			ASTKeyRefConstraint subnode = (ASTKeyRefConstraint) node.jjtGetChild(0);
			constraint =
				this.visit(subnode, null);
		}

		return constraint;

	}



	public UniqueConstraint visit(
			ASTUniqueConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		UniqueConstraint uniqueConstraint =
			new UniqueConstraint(this.visit(subnode, null),
					node.getSelector(), node.getFields());
		return uniqueConstraint;
	}



	public KeyConstraint visit(
			ASTKeyConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		KeyConstraint keyConstraint =
			new KeyConstraint(node.getName(), this.visit(subnode, null),
					node.getSelector(), node.getFields());
		return keyConstraint;
	}



	public KeyRefConstraint visit(
			ASTKeyRefConstraint node, Object data) {
		ASTAPattern subnode = (ASTAPattern) node.jjtGetChild(0);
		KeyRefConstraint keyRefConstraint =
			new KeyRefConstraint(node.getName(),
					this.visit(subnode, null), node.getSelector(), node.getFields());
		return keyRefConstraint;
	}




	public GroupList visit(ASTGroupBlock node, Object data) {

		GroupList groupList = new GroupList();
		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			ASTGroupRule subnode = (ASTGroupRule) node.jjtGetChild(i);
			groupList.addGroupElement(this.visit(subnode, null));
		}
		return groupList;
	}


	public GroupElement visit(ASTGroupRule node, Object data) {


		if (node.getNodeChoice().equals("group")) {

			ASTRegex subnode = (ASTRegex) node.jjtGetChild(0);

			Particle particle = this.visit(subnode, null);
			ParticleContainer particleContainer = new SequencePattern();
			particleContainer.addParticle(particle);
			ElementGroupElement elementGroupElement =
				new ElementGroupElement(node.getName(), particleContainer);
			bonxai.getGroupSymbolTable().updateOrCreateReference(node.getName(), elementGroupElement);
			  return elementGroupElement;


		} else {
			
			ASTAttributePattern subnode = (ASTAttributePattern) node.jjtGetChild(0);
			
			AttributePattern attributePattern = this.visit(subnode, null);
			AttributeGroupElement attributeGroupElement =
				new AttributeGroupElement(node.getName(), attributePattern);
			bonxai.getAttributeGroupElementSymbolTable().updateOrCreateReference(node.getName(), attributeGroupElement);
			      return attributeGroupElement;
		}
	}




	public Expression visit(
			ASTExpr node, Object data) {
		
		// to be extended
		
		Expression expression = new Expression();
		AncestorPattern ancestorPattern;

		ChildPattern childPattern;

		if (node.jjtGetNumChildren() == 3) {

			ASTAnnotations annotationSubnode = (ASTAnnotations) node.jjtGetChild(0);
			ASTAPattern aPatternSubnode = (ASTAPattern) node.jjtGetChild(1);
			ASTCPattern cPatternSubnode = (ASTCPattern) node.jjtGetChild(2);
			expression =
				this.visit(annotationSubnode, expression);
			ancestorPattern =
				this.visit(aPatternSubnode, null);
			childPattern =
				this.visit(cPatternSubnode, null);
		} else {

			ASTAPattern aPatternSubnode = (ASTAPattern) node.jjtGetChild(0);
			ASTCPattern cPatternSubnode = (ASTCPattern) node.jjtGetChild(1);
			ancestorPattern =
				this.visit(aPatternSubnode, null);
			childPattern =
				this.visit(cPatternSubnode, null);
		}

		expression.setAncestorPattern(ancestorPattern);
		expression.setChildPattern(childPattern);
		return expression;
	}



	public Expression visit(
			ASTAnnotations node, Object data) {
		Expression expression = (Expression) data;
		for (int i = 0; i <
		node.jjtGetNumChildren(); i++) {
			ASTAnnotation subnode = (ASTAnnotation) node.jjtGetChild(i);
			expression.addAnnotation(this.visit(subnode, null));
		}

		return expression;
	}


	public AncestorPattern visit(
			ASTAPattern node, Object data) {

		if (node.getNodeChoice().equals("full")) {
			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);

		}
		else {

			if (node.getNodeChoice().equals("simple_full")) {

				ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
				ASTFullAPattern fullnode = (ASTFullAPattern) node.jjtGetChild(1);
				

			}
			else {

				ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
				
			}

		}

		return new AncestorPattern(null);
		
		
	}




	public AncestorPatternParticle visit(
			ASTSimpleAPattern node, Object data) {

		AncestorPatternParticle apattern;

		if (node.getName() != "") {

			

			String namespace;

			String name;


			name =  extractName(node.getName());
			namespace = extractIdentifier(node.getName());


			apattern = new DoubleSlashPrefixElement(namespace, name);


			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);



		}
		else {

			ASTSimpleAPatternOr subnode = (ASTSimpleAPatternOr) node.jjtGetChild(0);

			Vector<AncestorPatternParticle> orExpressionContent = new Vector<AncestorPatternParticle>();
			orExpressionContent.add(this.visit(subnode, null));


			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;


		}
		
		
 return apattern;


	}




	public AncestorPatternParticle visit(
			ASTFullAPatternOr  node, Object data) {


		if (node.jjtGetNumChildren() == 1) {
			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			ASTFullAPattern subnodeOne = (ASTFullAPattern) node.jjtGetChild(0);
			ASTFullAPattern subnodeTwo = (ASTFullAPattern) node.jjtGetChild(1);
			Vector<AncestorPatternParticle> orExpressionContent =
				new Vector<AncestorPatternParticle>();
			orExpressionContent.add(this.visit(subnodeOne, null));
			orExpressionContent.add(this.visit(subnodeTwo, null));
			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;



		}
	}



	public AncestorPatternParticle visit(
			ASTSimpleAPatternOr  node, Object data) {


		if (node.jjtGetNumChildren() == 1) {
			ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			ASTSimpleAPattern subnodeOne = (ASTSimpleAPattern) node.jjtGetChild(0);
			ASTSimpleAPattern subnodeTwo = (ASTSimpleAPattern) node.jjtGetChild(1);
			Vector<AncestorPatternParticle> orExpressionContent =
				new Vector<AncestorPatternParticle>();
			orExpressionContent.add(this.visit(subnodeOne, null));
			orExpressionContent.add(this.visit(subnodeTwo, null));
			OrExpression orExpression = new OrExpression(orExpressionContent);
			return orExpression;



		}
	}



	public AncestorPatternParticle visit(
			ASTFullAPattern node, Object data) {

		AncestorPatternParticle content;
		String namespace;

		String name;



		ASTSimpleAPattern parentnode = (ASTSimpleAPattern) node.jjtGetParent();

		name = extractName(parentnode.getName());
		namespace = extractIdentifier(parentnode.getName());


		if (node.getNodeChoice().equals("separator")) {

			if (node.getSeparator()) {


				content = new DoubleSlashPrefixElement(namespace, name);


			} else {


				content = new SingleSlashPrefixElement(namespace, name);

			}


			ASTSimpleAPattern subnode = (ASTSimpleAPattern) node.jjtGetChild(0);

		} else {

			ASTFullAPatternOr subnode = (ASTFullAPatternOr) node.jjtGetChild(0);


			if (node.getOperator() != "") {


				Integer min = 1;
				Integer max = 1;
				if (node.getOperator().equals("*")) {
					min = 0;
					max =
						null;
				} else if (node.getOperator().equals("+")) {
					min = 0;
					max =
						null;
				} else if (node.getOperator().equals("?")) {
					min = 0;
					max =
						1;
				}

				AncestorPatternParticle childContent = this.visit(subnode, null);
				content =new CardinalityParticle(childContent, min, max);

			}

		}


		if (node.getSequence()) {


			ASTFullAPattern subnode = (ASTFullAPattern) node.jjtGetChild(0);
			AncestorPatternParticle childContent = this.visit(subnode, null);
		
			Vector<AncestorPatternParticle> sequenceExpressionContent =  new Vector<AncestorPatternParticle>();
			sequenceExpressionContent.add(childContent);
			sequenceExpressionContent.add(this.visit(subnode, null));
			// return new SequenceExpression(sequenceExpressionContent);


		}


return null;

	}





	public Annotation visit(ASTAnnotation node, Object data) {


		String name="";
		String value="";

		for (int i = 0; i < node.jjtGetNumChildren(); i++) {
			if (node.jjtGetChild(i).getNodeType().equals("AnnotationName")) {
				ASTAnnotationName subnode = (ASTAnnotationName) node.jjtGetChild(0);
				name =  subnode.getName();
			}

			if (node.jjtGetChild(i).getNodeType().equals("AnnotationValue")) {
				ASTAnnotationValue subnode = (ASTAnnotationValue) node.jjtGetChild(0);
				value =  subnode.getName();
			}
		}


		Annotation annotation = new Annotation( name, value);

		return annotation;

	}

	// Visit implementation not necessary for: AnnotaionName, Annotation Value


	public Particle visit( ASTRegex node, Object data) {


		if (node.getNodeChoice().equals("regex")) {


			// (regex)
			if (node.getOperator() == "" && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);


			}

			// (regex)* | (regex)+

			if ( (node.getOperator() == "*" || node.getOperator() == "+") && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, null);


			}

			// regex ?
			if (node.getOperator() == "?" && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, 1);


			}

			// regex [n]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 && node.getNumberAfter() == 0 && node.getSecondOperator()=="") {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, node.getNumberBefore());


			}

			// regex [n, n ]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 &&  node.getNumberAfter() > 0 && node.getSecondOperator()=="") {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(  node.getNumberBefore(), node.getNumberAfter());


			}

			// regex [n *]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 && node.getNumberAfter() == 0 && node.getSecondOperator()=="*") {

				ASTRegex nextRegex = (ASTRegex) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern( node.getNumberBefore(), null );


			} 



		}



		if (node.getNodeChoice().equals("named_type_single")) {

			// (NamedType)
			if (node.getOperator() == "" && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);


			}

			// (NamedType)* | (NamedType)+

			if ( (node.getOperator() == "*" || node.getOperator() == "+") && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, null);


			}

			// NamedType ? 

			if (node.getOperator() == "?" && node.getNumberBefore() == 0 && node.getNumberAfter() == 0) {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, 1);


			}

			// NamedType[n]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 && node.getNumberAfter() == 0 && node.getSecondOperator()=="") {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(0, node.getNumberBefore());


			}

			// NamedType[n, n ]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 && node.getNumberAfter() > 0 && node.getSecondOperator()=="") {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern(  node.getNumberBefore(), node.getNumberAfter());


			}

			// NamedType [n *]
			if (node.getOperator() == "" && node.getNumberBefore() > 0 && node.getNumberAfter() == 0 && node.getSecondOperator()=="*") {

				ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
				CountingPattern countingPattern = new CountingPattern( node.getNumberBefore(), null );


			} 

		
		
		}


		if (node.getNodeChoice().equals("named_type_comma")) {


			ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
			SequencePattern sequencePattern = new SequencePattern();
			sequencePattern.addParticle(this.visit(namedType, null));

		}


		if (node.getNodeChoice().equals("named_type_or")) {


			ASTNamedType namedType = (ASTNamedType) node.jjtGetChild(0);
			ChoicePattern choicePattern = new ChoicePattern();
			choicePattern.addParticle(this.visit(namedType, null));

		}






		return null;



	}




	public Element visit(ASTNamedType node, Object data) {



		if (node.getNodeChoice().equals("element")) {
			de.tudortmund.cs.bonxai.bonxai.Element content;

			String name = extractName(node.getName());
			String namespace = extractIdentifier(node.getName());

			if (node.jjtGetNumChildren() == 0) {
				content = new de.tudortmund.cs.bonxai.bonxai.Element(namespace, name);

			} else {
				ASTBonxaiType subnode = (ASTBonxaiType) node.jjtGetChild(1);
				BonxaiType bonxaiType = this.visit(subnode, null);
				content =
					new de.tudortmund.cs.bonxai.bonxai.Element(
							namespace, name, bonxaiType, subnode.getMissing());
				if (subnode.getDefault()) {
					content.setDefault(subnode.getName());
				}

				if (subnode.getFixed()) {
					content.setFixed(subnode.getName());
				}

			}
			return content;


		}



		if (node.getNodeChoice().equals("group")) {

			GroupRef groupRef = new GroupRef(
					bonxai.getGroupSymbolTable().getReference(node.getName()));

		}


		if (node.getNodeChoice().equals("foreign")) {

			String namespace ="";
			// Wie namespaceListe Vector in String ?!  String namespace = node.getNameSpaceList();
			AnyPattern anyPattern;
			Integer max;
			if (node.getForeign().equals("lax")) {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Lax, namespace);
			} else if (node.getForeign().equals("skip")) {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Skip, namespace);
			} else {
				anyPattern = new AnyPattern(ProcessContentsInstruction.Strict, namespace);
			}

			if (node.getNumberBefore() >0 && node.getNumberAfter() ==0) {

				CountingPattern countingPattern =
					new CountingPattern(node.getNumberBefore(), null);
				countingPattern.addParticle(anyPattern);


			}


			if (node.getNumberBefore() >0 && node.getNumberAfter() >0) {

				CountingPattern countingPattern =
					new CountingPattern(node.getNumberBefore(), node.getNumberAfter());
				countingPattern.addParticle(anyPattern);


			}



		}
		return null;
	}




	public Particle visit(ASTAll node, Object data) {
		if (node.jjtGetNumChildren() == 1) {
			ASTNamedType subnode = (ASTNamedType) node.jjtGetChild(0);
			return this.visit(subnode, null);
		} else {
			AllPattern allPattern = new AllPattern();
			for (int i = 0; i < node.jjtGetNumChildren(); i++) {
				ASTNamedType subnode = (ASTNamedType) node.jjtGetChild(i);
				allPattern.addParticle(this.visit(subnode, null));
			}
			return allPattern;
		}
	}


	@Override
	public Object visit(ASTNamespaceUriLiteral node, Object data) {
		// implementation not necessary
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASThost node, Object data) {
		// implementation not necessary
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTConstraintSelector node, Object data) {
		// implementation not necessary
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTConstraintFields node, Object data) {
		// implementation not necessary
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public GrammarList visit(ASTBlock node, Object data) {
		GrammarList grammarList = new GrammarList();
		for (Node subnode: node.children) {
			if (subnode.getNodeType().equals("RootElements")) {
				this.visit((ASTRootElements) subnode, grammarList);
			} else if (subnode.getNodeType().equals("Expr")) {
				grammarList.addExpression(this.visit((ASTExpr) subnode, null));
			}
		}
		
		return grammarList;
	}


	@Override
	public Object visit(ASTAnnotationName node, Object data) {
		// implementation not necessary
		// TODO Auto-generated method stub
		return null;
	}


	public Object visit(ASTFullAPatternHead node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTPathSeparator node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTOperator node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public ChildPattern visit(ASTCPattern node, Object data) {
        AttributePattern attributePattern;
        ASTElementPattern elementSubnode;

        if (node.jjtGetNumChildren() == 1) {
            attributePattern = new AttributePattern();
            elementSubnode =
                    (ASTElementPattern) node.jjtGetChild(0);
        } else {
            ASTAttributePattern subnode = (ASTAttributePattern) node.jjtGetChild(0);
            attributePattern =
                    this.visit(subnode, null);
            elementSubnode =
                    (ASTElementPattern) node.jjtGetChild(1);
        }

        ElementPattern elementPattern = this.visit(elementSubnode, null);
        ChildPattern content = new ChildPattern(attributePattern, elementPattern);
        return content;
	}


	@Override
	public ElementPattern visit(ASTElementPattern node, Object data) {
		 ElementPattern elementPattern;
	        if (node.getEmpty()) {
	            elementPattern = null;
	        } else {
	            if (node.jjtGetChild(0).getNodeType().equals("BonxaiType")) {
	                ASTBonxaiType subnode = (ASTBonxaiType) node.jjtGetChild(0);
	                elementPattern =
	                        new ElementPattern(this.visit(subnode, null), node.getMissing());
	                if (subnode.getDefault()) {
	                    elementPattern.setDefault(subnode.getName());
	                }

	                if (subnode.getFixed()) {
	                    elementPattern.setFixed(subnode.getName());
	                }

	            } else {
	                ASTMixedRegex subnode = (ASTMixedRegex) node.jjtGetChild(0);
	                elementPattern =
	                        new ElementPattern(this.visit(subnode, null), node.getMissing());
	            }

	        }
	        return elementPattern;
	}


	@Override
	public Particle visit(ASTMixedRegex node, Object data) {
		 Particle content;
	        if (node.jjtGetChild(0).getNodeType().equals("All")) {
	            ASTAll subnode = (ASTAll) node.jjtGetChild(0);
	            content =
	                    this.visit(subnode, null);
	        } else {
	            ASTRegex subnode = (ASTRegex) node.jjtGetChild(0);
	            content =
	                    this.visit(subnode, null);
	        }
	        if (contentModelValidation) {
	            try {
	                ContentModelValidator validator = new ContentModelValidator(content);
	                validator.checkDeterminism();
	            } catch (UPAViolationException ex) {
	                Logger.getLogger(Visitor.class.getName()).log(Level.SEVERE, null, ex);
	            } catch (RecursiveContentModelException ex) {
	                Logger.getLogger(Visitor.class.getName()).log(Level.SEVERE, null, ex);
	            }
	        }
	        return content;
	}


	@Override
	public AttributePattern visit(ASTAttributePattern node, Object data) {
		 AttributePattern attributePattern = new AttributePattern();
		 
		 ProcessContentsInstruction instruction;
		 if (node.getForeign().equals("lax")) {
	            instruction = ProcessContentsInstruction.Lax;
	        } else if (node.getForeign().equals("strict")) {
	            instruction = ProcessContentsInstruction.Strict;
	        } else {
	            instruction = ProcessContentsInstruction.Skip;
	        }
		 // Frage: String setzen, aber DS liefert eine Liste!! so eher nicht
	        AnyAttribute anyAttribute = new AnyAttribute(instruction, node.getNamespaceList().toString());
		 
	        
	        if (node.getAttributeList().size()>1) {
	        
	        
	        }
		 
		 Vector<AttributeListElement> attributeList = new Vector<AttributeListElement>();
		 
		 
		 for(int i=0; i < node.getAttributeList().size(); i++) {
			
			 
			 AttributeGroupReference attributeGroupReference =
	                new AttributeGroupReference(
	                bonxai.getAttributeGroupElementSymbolTable().getReference(node.getAttributeList().get(i).toString()));
			 
			 Attribute attribute;
		        String name = extractName( node.getAttributeList().get(i).toString());
		        String namespace = extractIdentifier( node.getAttributeList().get(i).toString());
		        if (node.jjtGetNumChildren() == 0) {
		        	// gibt keinen type ?! name eher falsch
		            String typeNamespace = extractIdentifier(node.getAttributeList().get(i).toString());
		            String type = extractName(node.getAttributeList().get(i).toString());
		            BonxaiType bonxaiType = new BonxaiType(namespace, type);
		            attribute = new Attribute(namespace, name, bonxaiType);
		        } else {
		            ASTAttrBonxaiType subnode = (ASTAttrBonxaiType) node.jjtGetChild(0);
		            BonxaiType bonxaiType = this.visit(subnode, null);
		            attribute = new Attribute(namespace, name, bonxaiType);
		            if (subnode.getDeafult()) {
		                attribute.setDefault(subnode.getName());
		            }
		            if (subnode.getFixed()) {
		                attribute.setFixed(subnode.getName());
		            }
		        }
		       
			 
			 
			 attributePattern.addAttribute(attribute);
			 
		 }
		 
		 attributePattern.setAttributeList(attributeList);
		 
		 return attributePattern;
	}


	@Override
	public Object visit(ASTAttributeList node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTNameSpaceList node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTForeign node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public BonxaiType visit(ASTBonxaiType node, Object data) {
		String namespace = extractIdentifier(node.getType());
        String type = extractName(node.getType());
        BonxaiType bonxaiType = new BonxaiType(namespace, type);
        return bonxaiType;
	}


	@Override
	public BonxaiType visit(ASTAttrBonxaiType node, Object data) {
        String namespace = extractIdentifier(node.getType());
        String type = extractName(node.getType());
        BonxaiType bonxaiType = new BonxaiType(namespace, type);
        return bonxaiType;
	}


	@Override
	public Object visit(ASTIdentifier node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTQuotationName node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTName node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Object visit(ASTNumber node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}
	
	
    public String extractName(
            String nameWithPossibleIdentifier) {
        //Initially namespace is the default namespace
        String namespace = bonxai.getDeclaration().getNamespaceList().getDefaultNamespace().getUri();
        String name = nameWithPossibleIdentifier;
        String nameWithoutIdentifierAndColon = "";
        String possibleIdentifier = "";
        //BEGIN: Cropping construction for Identifier extraction
        for (int i = 0; i <
                nameWithPossibleIdentifier.length() - 1; i++) {
            if ((i > 0) && nameWithPossibleIdentifier.substring(i, i + 1).equals(":")) {
                possibleIdentifier = nameWithPossibleIdentifier.substring(0, i);
                nameWithoutIdentifierAndColon =
                        nameWithPossibleIdentifier.substring(i + 1, nameWithPossibleIdentifier.length());
            }

        }

        if (possibleIdentifier.isEmpty()) {
            if (name.startsWith(":")) {
                //name stays name
                }
        }

        if (possibleIdentifier.isEmpty()) {
            if (name.endsWith(":")) {
                //name stays name
                }
        }

        //END: Cropping construction for Identifier extraction
        if (possibleIdentifier.isEmpty()) {
            //name stays name
            } else {
            if (bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri() != null) {
                namespace = bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri();
                name =
                        nameWithoutIdentifierAndColon;
            }

        }
        return name;
    }

    public String extractIdentifier(
            String nameWithPossibleIdentifier) {
        //Initially namespace is the default namespace
        String namespace = bonxai.getDeclaration().getNamespaceList().getDefaultNamespace().getUri();
        String name = nameWithPossibleIdentifier;
        String nameWithoutIdentifierAndColon = "";
        String possibleIdentifier = "";
        //BEGIN: Cropping construction for Identifier extraction
        for (int i = 0; i <
                nameWithPossibleIdentifier.length() - 1; i++) {
            if ((i > 0) && nameWithPossibleIdentifier.substring(i, i + 1).equals(":")) {
                possibleIdentifier = nameWithPossibleIdentifier.substring(0, i);
                nameWithoutIdentifierAndColon =
                        nameWithPossibleIdentifier.substring(i + 1, nameWithPossibleIdentifier.length() - 1);
            }

        }

        if (possibleIdentifier.isEmpty()) {
            if (name.startsWith(":")) {
                //name stays name
                }
        }

        if (possibleIdentifier.isEmpty()) {
            if (name.endsWith(":")) {
                //name stays name
            }
        }

        //END: Cropping construction for Identifier extraction
        if (possibleIdentifier.isEmpty()) {
            //name stays name
            } else {
            if (bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri() != null) {
                namespace = bonxai.getDeclaration().getNamespaceList().getNamespaceByIdentifier(possibleIdentifier).getUri();
                name =
                        nameWithoutIdentifierAndColon;
            }

        }
        return namespace;
    }


	@Override
	public Object visit(ASTAnnotationValue node, Object data) {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public Vector<String> visit(ASTRootElements node, Object data) {
		return node.getRootElementNames();
	}




}
/* JavaCC - OriginalChecksum=61392cb8ba6d017f5680f7409376633d (do not edit this line) */
