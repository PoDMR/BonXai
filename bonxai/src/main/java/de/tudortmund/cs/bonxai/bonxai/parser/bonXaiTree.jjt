options {
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = false;
  UNICODE_INPUT = true;
  JAVA_UNICODE_ESCAPE = true;
  MULTI = true;
  NODE_DEFAULT_VOID = true;
  VISITOR = true;
  STATIC = false;
 }




PARSER_BEGIN(bonXaiTree)

package de.tudortmund.cs.bonxai.bonxai.parser;

import java.util.*;

public class bonXaiTree {

}

PARSER_END(bonXaiTree)





SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <VAR_WS>
}




TOKEN :
{
    	<CONSTANT: ( <DIGIT> )+ >
|	<OPENING_ROUND_BRACKET: "("> 
|	<CLOSING_ROUND_BRACKET: ")"> 
|	<OPENING_SQUARED_BRACKET: "["> 
|	<CLOSING_SQUARED_BRACKET: "]"> 
|	<OPENING_CURLY_BRACKET: "{"> 
|	<CLOSING_CURLY_BRACKET: "}">
|	<EQUALS: "="> 
|	<COMMA: ","> 
|	<AT: "@" > 
|	<OR: "|" >
|	<ANDLITERAL: "&">
//|	<LOWERCASE: ["a" - "z"] >
//|	<CAPITLAS: ["A" - "Z"] >
|	<SLASH: "/" >: VARIABLE
|	<DOUBLESLASH: "//" >: VARIABLE
|	<BACKSLASH: "\\">
|	<STAR: "*" >
|	<PLUS: "+" >
|	<QUESTION_MARK: "?" >
|	<QUOTE:"\"">:QUOTATION
|	<UNDERSCORE: "_" >
|	<COLON: ":" >:VARIABLE
|	<DBCOLON: "::" >
|	<POINT: ".">
|	<DBPOINT: "..">
|	<MINUS: "-">
//|	<ANNOTATION_VALUE: (~["\n", "\r"])+ >
|	<ANNOTATION_VALUE: "annotaion">




|	< ROOTS: "roots" >: VARIABLE_OR
| 	< GRAMMAR: "grammar"  >
|	< DEFAULT_NAMESPACE: "default namespace">
|	< NAMESPACE: "namespace" >: VARIABLE 
|	< TYPE: "type" >:VARIABLE
|	< DEFAULTT: "default" >
|	< DATATYPES: "datatypes " >: VARIABLE
|	< IMPORT: "import" >
|	< CONSTRAINTS: "constraints" >
|	< UNIQUE: "unique" >
|	< KEY: "key" >: VARIABLE
|	< KEYREF: "keyref " >: VARIABLE
|	< GROUPS: "groups" >
|	< GROUP: "group" >: VARIABLE
|	< ATTRIBUTEGROUP: "attribute-group" >: VARIABLE
|	< ATTRIBUTE: "attribute" >: VARIABLE
|	< MIXED: "mixed" >
|	< EMPTY: "empty" >
|	< MISSING: "missing" >
|	< MISSING_OR: "missing |" >
|	< ELEMENT: "element" >: VARIABLE
|	< ELEMENT_STAR: "element *" >:  NAMESPACE_LIST
|	< STRICT: "strict" >
|	< LAX: "lax" >
|	< SKIPP: "skip" >
|	< FIXED: "fixed" >  
|	< RETURN: "return" >  // XPath Token
|	< FOR: "for" >
|	< IN: "in" >
|	< DOLLAR: "$" >
|	< SOME: "some" >
|	< EVERY: "every" >
|	< SATISFIES: "satisfies" >
|	< IF: "if" >
|	< THEN: "then" >
|	< ELSE: "else" >
|	< AND: "and" >
|	< TO: "to" >
|	< DIV: "div" >
|	< IDIV: "idiv" >
|	< MOD: "mod" >
|	< UNION: "union" >
|	< INTERSECT: "intersect" >
|	< EXCEPT: "except" >
|	< INSTANCE: "instance" >
|	< OF: "of" >
|	< TREAT: "treat" >
|	< AS: "as" > 
|	< CASTABLE: "castable" >
|	< CAST: "cast" >
|	< NOTEQUAL: "!=" >
|	< LESSTHAN: "<" >
|	< LESSEQUAL: "<=" >
|	< GREATERTHAN: ">" >
|	< GREATEREQUAL: ">=" >
|	< EQ: "eq"> 
|	< NE: "ne" >
|	< LT: "lt" >
|	< LE: "le" >
|	< GT: "gt" >
|	< GE: "ge" >
|	< IS: "is" >
|	< DBLEFT: "<<" >
|	< DBRIGHT: ">>" >
|	< CHILD: "child" >
|	< DESCENDANT: "descendant" >
|	< SELF: "self" >
|	< DESCENDANTORSELF: "descendant-or-self" >
|	< FOLLOWINGSIBLING: "following-sibling" >
|	< FOLLOWING: "following" >
|	< PARENT: "parent" >
|	< ANCESTOR: "ancestor" >
|	< PRECEDINGSIBLING: "preceding-sibling" >
|	< PRECEDING: "preceding" >
|	< ANCESTORORSELF: "ancestor-or-self" >
|	< EMPTYSEQUENCE: "empty-sequence" >
|	< ITEM: "item" >
|	< NODE: "node" >
|	< DOCUMENTNODE: "document-node" >
|	< TEXT: "text" > 
|	< COMMENT: "comment" > 
|	< PROCESSINGINSTRUCTION: "processing-instruction" >  
|	< SCHEMAATTRIBUTE: "schema-attribute" > 
|	< SCHEMAELEMENT: "schema-element" >

|
	<DIGIT: (["0"-"9"])> |
	<BASECHAR: [ 
		"A"-"Z", 
		"a"-"z", 
		"\u00c0"-"\u00d6",
		"\u00d8"-"\u00f6",
		"\u00f8"-"\u00ff",
		"\u0100"-"\u0131",
	    "\u0134"-"\u013e",
		"\u0141"-"\u0148",
		"\u014a"-"\u017e", 
	    "\u0180"-"\u01c3",
		"\u01cd"-"\u01f0",
		"\u01f4"-"\u01f5",
	    "\u01fa"-"\u0217",
		"\u0250"-"\u02a8",
		"\u02bb"-"\u02c1",
		"\u0386",
		"\u0388"-"\u038a",
		"\u038c",
		"\u038e"-"\u03a1",
		"\u03a3"-"\u03ce",
		"\u03d0"-"\u03d6",
		"\u03da",
		"\u03dc",
		"\u03de",
		"\u03e0",
		"\u0401"-"\u040c",
		"\u03e2"-"\u03f3",
		"\u040e"-"\u044f",
		"\u0451"-"\u045c",
		"\u045e"-"\u0481",
		"\u0490"-"\u04c4",
		"\u04c7"-"\u04c8",
		"\u04cb"-"\u04cc",
		"\u04d0"-"\u04eb",
		"\u04ee"-"\u04f5",
		"\u04f8"-"\u04f9",
		"\u0531"-"\u0556",
		"\u0559", 
		"\u0561"-"\u0586",
		"\u05d0"-"\u05ea",
		"\u05f0"-"\u05f2",
		"\u0621"-"\u063a",
		"\u0641"-"\u064a",
		"\u0671"-"\u06b7",
		"\u06ba"-"\u06be",
		"\u06c0"-"\u06ce",
		"\u06d0"-"\u06d3",
		"\u06d5",
		"\u06e5"-"\u06e6",
		"\u0905"-"\u0939",
		"\u093d",
		"\u0958"-"\u0961",
		"\u0985"-"\u098c",
		"\u098f"-"\u0990",
		"\u0993"-"\u09a8",
		"\u09aa"-"\u09b0",
		"\u09b2",
		"\u09b6"-"\u09b9", 
		"\u09dc"-"\u09dd",
		"\u09df"-"\u09e1",
		"\u09f0"-"\u09f1",
		"\u0a05"-"\u0a0a",
		"\u0a0f"-"\u0a10",
		"\u0a13"-"\u0a28",
		"\u0a2a"-"\u0a30",
		"\u0a32"-"\u0a33",
		"\u0a35"-"\u0a36",
		"\u0a38"-"\u0a39",
		"\u0a59"-"\u0a5c",
		"\u0a5e",
		"\u0a72"-"\u0a74",
		"\u0a85"-"\u0a8b",
		"\u0a8d",
		"\u0a8f"-"\u0a91",
		"\u0a93"-"\u0aa8",
		"\u0aaa"-"\u0ab0",
		"\u0ab2"-"\u0ab3",
		"\u0ab5"-"\u0ab9",
		"\u0abd",
		"\u0ae0",
		"\u0b05"-"\u0b0c",
		"\u0b0f"-"\u0b10",
		"\u0b13"-"\u0b28",
		"\u0b2a"-"\u0b30",
		"\u0b32"-"\u0b33",
		"\u0b36"-"\u0b39",
		"\u0b3d",
		"\u0b5c"-"\u0b5d",
		"\u0b5f"-"\u0b61",
		"\u0b85"-"\u0b8a",
		"\u0b8e"-"\u0b90",
		"\u0b92"-"\u0b95",
		"\u0b99"-"\u0b9a",
		"\u0b9c",
		"\u0b9e"-"\u0b9f",
		"\u0ba3"-"\u0ba4",
		"\u0ba8"-"\u0baa",
		"\u0bae"-"\u0bb5",
		"\u0bb7"-"\u0bb9",
		"\u0c05"-"\u0c0c",
		"\u0c0e"-"\u0c10",
		"\u0c12"-"\u0c28",
		"\u0c2a"-"\u0c33",
		"\u0c35"-"\u0c39",
		"\u0c60"-"\u0c61",
		"\u0c85"-"\u0c8c",
		"\u0c8e"-"\u0c90",
		"\u0c92"-"\u0ca8",
		"\u0caa"-"\u0cb3",
		"\u0cb5"-"\u0cb9",
		"\u0cde",
		"\u0ce0"-"\u0ce1",
		"\u0d05"-"\u0d0c",
		"\u0d0e"-"\u0d10",
		"\u0d12"-"\u0d28",
		"\u0d2a"-"\u0d39",
		"\u0d60"-"\u0d61",
		"\u0e01"-"\u0e2e",
		"\u0e30",
		"\u0e32"-"\u0e33",
		"\u0e40"-"\u0e45",
		"\u0e81"-"\u0e82",
		"\u0e84",
		"\u0e87"-"\u0e88",
		"\u0e8a",
		"\u0e8d",
		"\u0e94"-"\u0e97",
		"\u0e99"-"\u0e9f",
		"\u0ea1"-"\u0ea3",
		"\u0ea5",
		"\u0ea7",
		"\u0eaa"-"\u0eab",
		"\u0ead"-"\u0eae",
		"\u0eb0",
		"\u0eb2"-"\u0eb3",
		"\u0ebd",
		"\u0ec0"-"\u0ec4", 
		"\u0f40"-"\u0f47",
		"\u0f49"-"\u0f69",
		"\u10a0"-"\u10c5",
		"\u10d0"-"\u10f6",
		"\u1100",
		"\u1102"-"\u1103",
		"\u1105"-"\u1107",
		"\u1109",
		"\u110b"-"\u110c",
		"\u110e"-"\u1112",
		"\u113c",
		"\u113e",
		"\u1140",
		"\u114c",
		"\u114e",
		"\u1150",
		"\u1154"-"\u1155",
		"\u1159",
		"\u115f"-"\u1161",
		"\u1163",
		"\u1165",
		"\u1167",
		"\u1169",
		"\u116d"-"\u116e",
		"\u1172"-"\u1173",
		"\u1175",
		"\u119e",
		"\u11a8",
		"\u11ab",
		"\u11ae"-"\u11af",
		"\u11b7"-"\u11b8",
		"\u11ba",
		"\u11bc"-"\u11c2",
		"\u11eb",
		"\u11f0",
		"\u11f9",
		"\u1e00"-"\u1e9b",
		"\u1ea0"-"\u1ef9",
		"\u1f00"-"\u1f15",
		"\u1f18"-"\u1f1d",
		"\u1f20"-"\u1f45",
		"\u1f48"-"\u1f4d",
		"\u1f50"-"\u1f57",
		"\u1f59",
		"\u1f5b","\u1f5d",
		"\u1f5f"-"\u1f7d",
		"\u1f80"-"\u1fb4",
		"\u1fb6"-"\u1fbc",
		"\u1fbe",
		"\u1fc2"-"\u1fc4",
		"\u1fc6"-"\u1fcc",
		"\u1fd0"-"\u1fd3",
		"\u1fd6"-"\u1fdb",
		"\u1fe0"-"\u1fec",
		"\u1ff2"-"\u1ff4",
		"\u1ff6"-"\u1ffc",
		"\u2126",
		"\u212a"-"\u212b",
		"\u212e",
		"\u2180"-"\u2182",
		"\u3041"-"\u3094",
		"\u30a1"-"\u30fa",
		"\u3105"-"\u312c",
		"\uac00"-"\ud7a3"

] > 
| <IDEOGRAPHIC: [
		"\u4e00"-"\u9fa5",
		"\u3007",
		"\u3021"-"\u3029"
	] > |
	
	<COMBINING_CHAR: [
		"\u0300"-"\u0345",
		"\u0360"-"\u0361",
		"\u0483"-"\u0486",
		"\u0591"-"\u05a1",
		"\u05a3"-"\u05b9", 
		"\u05bb"-"\u05bd",
		"\u05bf",
		"\u05c1"-"\u05c2",
		"\u05c4",
		"\u064b"-"\u0652",
		"\u0670",
		"\u06d6"-"\u06dc",
		"\u06dd"-"\u06df",
		"\u06e0"-"\u06e4",
		"\u06e7"-"\u06e8",
		"\u06ea"-"\u06ed",
		"\u0901"-"\u0903",
		"\u093c",
		"\u093e"-"\u094c", 
		"\u094d", 
		"\u0951"-"\u0954",
		"\u0962"-"\u0963", 
		"\u0981"-"\u0983", 
		"\u09bc",
		"\u09be",
		"\u09bf",
		"\u09c0"-"\u09c4", 
		"\u09c7"-"\u09c8", 
		"\u09cb"-"\u09cd", 
		"\u09d7",
		"\u09e2"-"\u09e3",
		"\u0a02", 
		"\u0a3c", "\u0a3e",
		"\u0a3f",
		"\u0a40"-"\u0a42",
		"\u0a47"-"\u0a48",
		"\u0a4b"-"\u0a4d",
		"\u0a70"-"\u0a71",
		"\u0a81"-"\u0a83",
		"\u0abc",
		"\u0abe"-"\u0ac5",
		"\u0ac7"-"\u0ac9",
		"\u0acb"-"\u0acd",
		"\u0b01"-"\u0b03",
		"\u0b3c",
		"\u0b3e"-"\u0b43",
		"\u0b47"-"\u0b48",
		"\u0b4b"-"\u0b4d",
		"\u0b56"-"\u0b57",
		"\u0b82"-"\u0b83",
		"\u0bbe"-"\u0bc2",
		"\u0bc6"-"\u0bc8",
		"\u0bca"-"\u0bcd",
		"\u0bd7",
		"\u0c01"-"\u0c03",
		"\u0c3e"-"\u0c44", 
		"\u0c46"-"\u0c48",
		"\u0c4a"-"\u0c4d",
		"\u0c55"-"\u0c56", 
		"\u0c82"-"\u0c83",
		"\u0cbe"-"\u0cc4",
		"\u0cc6"-"\u0cc8",
		"\u0cca"-"\u0ccd",
		"\u0cd5"-"\u0cd6",
		"\u0d02"-"\u0d03",
		"\u0d3e"-"\u0d43",
		"\u0d46"-"\u0d48",
		"\u0d4a"-"\u0d4d",
		"\u0d57",
		"\u0e31",
		"\u0e34"-"\u0e3a",
		"\u0e47"-"\u0e4e",
		"\u0eb1",
		"\u0eb4"-"\u0eb9",
		"\u0ebb"-"\u0ebc",
		"\u0ec8"-"\u0ecd",
		"\u0f18"-"\u0f19",
		"\u0f35", 
		"\u0f37",
		"\u0f39", 
		"\u0f3e",
		"\u0f3f",
		"\u0f71"-"\u0f84",
		"\u0f86"-"\u0f8b",
		"\u0f90"-"\u0f95",
		"\u0f97",
		"\u0f99"-"\u0fad",
		"\u0fb1"-"\u0fb7",
		"\u0fb9",
		"\u20d0"-"\u20dc",
		"\u20e1", 
		"\u302a"-"\u302f",
		"\u3099",
		"\u309a"
		]> |
	
<EXTENDER: [
		"\u00b7",
		"\u02d0",
		"\u02d1",
		"\u0387",
		"\u0640",
		"\u0e46",
		"\u0ec6",
		"\u3005",
		"\u3031"-"\u3035",
		"\u309d"-"\u309e",
		"\u30fc"-"\u30fe"
		] > 

        


|	<HTTP : "http://" >:URI
|	<FTP : "ftp://" >:URI 


}

<URI> TOKEN: {

	<URI_LABEL: (<BASECHAR>)+ >
|	<URI_POINT: "." >
|	<URI_SLASH: "/" >
|	<URI_CONSTANT: ( <DIGIT> )+ >
//|	<URI_SEMICOLON: ";"> :DEFAULT 
|	<URI_WS: " "> :DEFAULT 
| 	<URI_ROW: "\r">:DEFAULT
| 	<URI_LINE: "\n">:DEFAULT

}


<VARIABLE> TOKEN: {

	<VAR_LABEL: (<BASECHAR>)(<BASECHAR> | <DIGIT>)* >:DEFAULT
|	<VAR_CONSTANT: ( <DIGIT> )+ >:DEFAULT
|	<VAR_OPENING_ROUND_BRACKET: "(">:VARIABLE_OR 
|	<VAR_AT: "@" > 
|   <VAR_COLON: ":" >
}

<VARIABLE> SKIP: {
 " " | "\r" | "\n"  
}

<VARIABLE_OR> TOKEN: {

	<VAROR_LABEL: (<BASECHAR>)(<BASECHAR> | <DIGIT>)* >
|	<VAROR_CONSTANT: ( <DIGIT> )+ >
|	<VAROR_OR: "|">
|	<VAROR_COMMA: ",">
|	<VAR_CLOSING_ROUND_BRACKET: ")">:DEFAULT
|	<VAR_OPENING_CURLY_BRACKET: "{">
|	<VAR_CLOSING_CURLY_BRACKET: "}">:DEFAULT
|	<VAROR_AT: "@" > 
|   <VAROR_COLON: ":" >

}

<VARIABLE_OR> SKIP: {
 " " | "\r" | "\n"  
}

<QUOTATION> TOKEN: {

	<QUOT_LABEL: (<BASECHAR>)+ >
|	<QUOT_CONSTANT: ( <DIGIT> )+ >
|	<QOUT_WS: " ">  
|	<QUOT_QUOTE:"\"">:DEFAULT

}


<NAMESPACE_LIST> SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<NAMESPACE_LIST> TOKEN: {

	<LIST_LABEL: (<BASECHAR>)+ >
|	<START_LIST: "{" >
|	<LIST_COMMA: "," >
|	<END_LIST: "}" > :DEFAULT 


}








// Start symbol bonXai(); called by parser function
// Main entry point of the Bonxai grammar
//
// Bonxai              ::= Decl* GroupBlock? Block ConstraintBlock?

SimpleNode bonXai() #bonXai : {}
{

( Decl())* [GroupBlock()] Block() [ConstraintBlock()] <EOF>

{
	jjtThis.setNodeType("bonXai");
	return jjtThis;

}



}

// Decl                ::= "namespace" Identifier "=" NamespaceUriLiteral
//                      | "default" "namespace" NamespaceUriLiteral
//                      | "datatypes" Identifier "=" URL
//                      | "import" NamespaceUriLiteral ( "=" URL )?


void Decl() #Decl: {String uri="" ; String ident=""; String url="";}
{

(
 <NAMESPACE> ident=Identifier() <EQUALS> uri=NamespaceUriLiteral() { jjtThis.setNodeChoice("namespace"); }
| <DEFAULT_NAMESPACE> uri=NamespaceUriLiteral() { jjtThis.setNodeChoice("default"); }
| <DATATYPES> ident=Identifier() <EQUALS> url=NamespaceUriLiteral() { jjtThis.setNodeChoice("datatypes"); }
| <IMPORT> uri=NamespaceUriLiteral() [ <EQUALS> url=NamespaceUriLiteral() ] { jjtThis.setNodeChoice("import"); } 
) 

{
		jjtThis.setUri(uri);
		jjtThis.setIdentifier(ident);
		jjtThis.setUrl(url);
		jjtThis.setNodeType("declaration");
}
}


String NamespaceUriLiteral(): {Token t; String r; String s = "";}
{

//( <HTTP> | <FTP> )(<BASECHAR>| <CONSTANT> | <SLASH>|<POINT>)+

( t=<HTTP> | t=<FTP> ) { s = t.image;} r = host() {s = s + r;} ((t=<URI_WS>|t=<URI_ROW>|t=<URI_LINE>) {s = s + t.image; })

{ return s;}


}


String host(): {Token t; String s = "";}
{

t=<URI_LABEL> {s=t.image;} (((t=<URI_POINT>|t=<URI_SLASH>|t=<URI_CONSTANT>) {s = s + t.image;})*  t=<URI_LABEL> {s = s + t.image;})*

{return s;}

}




// ConstraintBlock     ::= "constraints" "{" Constraint+ "}"
// // is empty constraints possible? ::= "constraints" "{" (Constraint+)? "}"

void ConstraintBlock() #ConstraintBlock : {}
{

<CONSTRAINTS> <OPENING_CURLY_BRACKET> [(Constraint())+] <CLOSING_CURLY_BRACKET>

	{
		jjtThis.setNodeType("ConstraintBlock");
	}


}

//Constraint          ::= UniqueConstraint | KeyConstraint | KeyRefConstraint

void Constraint() #Constraint : {}
{

( UniqueConstraint() | KeyConstraint() | KeyRefConstraint() )

	{
		jjtThis.setNodeType("Constraint");
	}


}


//UniqueConstraint    ::= "unique" APattern "=" "{" ConstraintSelector ConstraintFields "}"
// EQUALS added ; see constraint example

void UniqueConstraint() #UniqueConstraint: {String selector; HashSet<String> fields;}
{


<UNIQUE> APattern() <EQUALS> <OPENING_CURLY_BRACKET> selector=ConstraintSelector() fields=ConstraintFields() <CLOSING_CURLY_BRACKET>

{
            jjtThis.setNodeType("UniqueConstraint");
		jjtThis.setSelector(selector);
		jjtThis.setFields(fields);
}

}

// KeyConstraint       ::= "key" Name APattern "{" ConstraintSelector ConstraintFields "}"


void KeyConstraint() #KeyConstraint : {String name; String selector; HashSet<String> fields;}
{

<KEY> name=Name() APattern() <EQUALS>  <OPENING_CURLY_BRACKET> selector=ConstraintSelector() fields=ConstraintFields() <CLOSING_CURLY_BRACKET>

{
            jjtThis.setName(name);
            jjtThis.setNodeType("KeyConstraint");
		jjtThis.setSelector(selector);
		jjtThis.setFields(fields);

}




}


// KeyRefConstraint    ::= "keyref" Name APattern "{" ConstraintSelector ConstraintFields "}"

void KeyRefConstraint() #KeyRefConstraint : {String name; String selector; HashSet<String> fields;}
{

<KEYREF> name=Name() APattern() <EQUALS>  <OPENING_CURLY_BRACKET> selector=ConstraintSelector() fields=ConstraintFields() <CLOSING_CURLY_BRACKET>

{
            jjtThis.setName(name);
            jjtThis.setNodeType("KeyConstraint");
		jjtThis.setSelector(selector);
		jjtThis.setFields(fields);

}



}

// ConstraintSelector  ::= XPath

String ConstraintSelector() #ConstraintSelector : {String s="";}
{

// point added
<POINT> s=XPath()

{return s;}

}  


// ConstraintFields    ::= "{" XPath ( "," XPath )* "}"
// Dummy return value!

HashSet<String> ConstraintFields() #ConstraintFields : {HashSet<String> xPathFields = new HashSet<String>(); String xPathField;}
{

//@ added
<OPENING_CURLY_BRACKET> <AT>  xPathField =  XPath() {xPathFields.add(xPathField);} ( <COMMA>  xPathField =  XPath() {xPathFields.add(xPathField);} )* <CLOSING_CURLY_BRACKET>

{return xPathFields;}

}    

// GroupBlock          ::= "groups" "{" GroupRule+ "}"

 void GroupBlock() #GroupBlock : {}
{

<GROUPS> <OPENING_CURLY_BRACKET> [(GroupRule())+] <CLOSING_CURLY_BRACKET>

	{
		jjtThis.setNodeType("GroupBlock");
	}


}

// GroupRule           ::= "group" Name "=" Regex
//                      | "attribute-group" Name "=" "{" AttributePattern "}"

void GroupRule() #GroupRule : {String name;}
{

( 
<GROUP> name=Name() <EQUALS> Regex() { jjtThis.setNodeChoice("group"); }
| <ATTRIBUTEGROUP> name=Name() <EQUALS> <OPENING_CURLY_BRACKET> AttributePattern() <CLOSING_CURLY_BRACKET> { jjtThis.setNodeChoice("attributegroup"); }
 )

	{
		jjtThis.setName(name);
		jjtThis.setNodeType("GroupRule");
	}



}

//Block               ::= "grammar" "{" Expr+ "}"
// is an empty grammar possible? ::= "grammar" "{" (Expr+)? "}"


void Block() #Block : {}
{

<GRAMMAR> <OPENING_CURLY_BRACKET> RootElements() [( Expr())+]  <CLOSING_CURLY_BRACKET>

	{
	jjtThis.setNodeType("Block");
	}



}

// RootElements
void RootElements() #RootElements: {String name=""; }
{
	<ROOTS> <VAR_OPENING_CURLY_BRACKET> [ name=Name() { jjtThis.addRoot(name); } ( <VAROR_COMMA> name=Name() { jjtThis.addRoot(name); } )* ] <VAR_CLOSING_CURLY_BRACKET>
	{
	jjtThis.setNodeType("RootElements");
	}
}


// Expr                ::= Annotations? APattern "=" "mixed"? CPattern


void Expr() #Expr: {}
{

[Annotations() ] APattern() <EQUALS> [<MIXED>] CPattern()


	{
	jjtThis.setNodeType("Expr");
	}


}


// Annotations         ::= ( Annotation )+

void Annotations() #Annotations : {}
{

( Annotation())+

	{
	jjtThis.setNodeType("Annotations");
	}


}

// old: Annotation            ::= AnnotationName AnnotationValue
// new: Annotation            ::= "@" AnnotationName? (" " AnnotationValue)?
void Annotation() #Annotation : {}
{

<AT>  [AnnotationName()] [AnnotationValue()]

	{
	jjtThis.setNodeType("Annotation");
	}


}


// AnnotationName      ::= "@" ["a"-"z", "A"-"Z"]+


void AnnotationName() #AnnotationName : {Token t; String name="";}
{

(t=<BASECHAR> {name=name + t.image;})+

	{
	jjtThis.setName(name);
	jjtThis.setNodeType("AnnotationName");
	}

}

void AnnotationValue() #AnnotationValue : {Token t; String name="";}
{

 (t=<BASECHAR> {name=name + t.image;})+

	{
	jjtThis.setName(name);
	jjtThis.setNodeType("AnnotationName");
	}





}

// AnnotationValue     ::= ~["\r", "\n"]+
// the tilde character (~) means NOT to the JavaCC tokenizer.
// not nessecary


// old:APattern            ::= SimpleAPattern FullAPattern? | FullAPattern
// new: APattern            ::= SimpleAPattern | FullAPattern

void APattern() #APattern : {}
{

( SimpleAPattern() [ LOOKAHEAD(2) FullAPattern() { jjtThis.setNodeChoice("simple_full"); }  ] | FullAPattern() { jjtThis.setNodeChoice("full"); }  )

      {
	jjtThis.setNodeType("APattern");
	}


}


//old:SimpleAPattern       ::= Name | "(" SimpleAPatternOr ")"
// new: SimpleAPattern       ::= Name | "@"Name | "(" SimpleAPatternOr ")"

void SimpleAPattern() #SimpleAPattern : {String name="";}
{

( name=Name() {jjtThis.setName(name);}  | (<VAR_AT> | <VAROR_AT>) ( name=Name() {jjtThis.setName(name); jjtThis.setAttribute(true); }) | <VAR_OPENING_ROUND_BRACKET> SimpleAPatternOr() <VAR_CLOSING_ROUND_BRACKET> )

      {
	jjtThis.setNodeType("SimpleAPattern");
	}

}

// old: SimpleAPatternOr     ::= SimpleAPattern ("|" SimpleAPattern)*
// new: SimpleAPatternOr     ::= SimpleAPattern ("|" SimpleAPattern)*

void SimpleAPatternOr() #SimpleAPatternOr : {}
{

SimpleAPattern() (<VAROR_OR> SimpleAPattern())*


      {
	jjtThis.setNodeType("SimpleAPatternOr");
	}


}


// old: FullAPattern       ::=    PathSeparator SimpleAPattern (FullAPattern)? | "(" FullAPatternOr ")" Operator?
// new: FullAPattern       ::=    PathSeparator SimpleAPattern | "(" FullAPatternOr ")" Operator? | FullAPattern FullAPattern
// without left recursion  ::=    PathSeparator SimpleAPattern | "(" FullAPatternOr ")" Operator? (FullAPattern)?
// correct without left recursion ::=   ( PathSeparator SimpleAPattern | "(" FullAPatternOr ")" Operator? ) (FullAPattern)?

void FullAPattern() #FullAPattern: {Boolean separator=false; Boolean sequence=false; String operator="";}
{
(	separator=PathSeparator() SimpleAPattern() { jjtThis.setNodeChoice("separator"); }  
| (<OPENING_ROUND_BRACKET>  FullAPatternOr() <CLOSING_ROUND_BRACKET> [operator=Operator() {jjtThis.setOperator(operator);} ]   { jjtThis.setNodeChoice("Or"); } ))  
 [FullAPattern() {sequence=true;} ] 

    {
      jjtThis.setSequence(sequence);
      jjtThis.setSeparator(separator);
	  jjtThis.setNodeType("FullAPattern");
	}

}




//FullAPatternHead   ::= 	PathSeparator Name 
// deleted production


// old: FullAPatternOr     ::= FullAPattern ("|" FullAPattern)*
// new: FullAPatternOr     ::= FullAPattern ("|" FullAPattern)*

void FullAPatternOr() #FullAPatternOr: {}
{

FullAPattern() (<OR> FullAPattern())*


      {
	jjtThis.setNodeType("FullAPatternOr");
	}


}


// PathSeparator      ::= "/" | "//"

Boolean PathSeparator() : {}
{

(<SLASH> {return false;} | <DOUBLESLASH> {return true;} )


}



// Operator           ::= "*" | "+" | "?"

String Operator(): {}
{

( <STAR> {return "*";} | <PLUS> {return "+";} | <QUESTION_MARK> {return "?";} )

}


// CPattern            ::= "{" ( AttributePattern "," )? ElementPattern "}"

void CPattern() #CPattern: {}
{

<OPENING_CURLY_BRACKET> [ LOOKAHEAD(2) AttributePattern() <COMMA> ] ElementPattern()  <CLOSING_CURLY_BRACKET>  

      {
	jjtThis.setNodeType("CPattern");
	}

}


// ElementPattern      ::= "empty"
//                      | "missing"? MixedRegex


void ElementPattern() #ElementPattern: {Boolean empty=false; Boolean missing=false;}
{

( <EMPTY> {empty=true;} | [ LOOKAHEAD(2) <MISSING> {missing=true;} ] MixedRegex() )


      {
      jjtThis.setEmpty(empty);
	jjtThis.setMissing(missing);
	jjtThis.setNodeType("ElementPattern");
	}

}


// MixedRegex          ::= All
//                      | Regex
//                      | BonxaiType

void MixedRegex() #MixedRegex : {}
{ 

( LOOKAHEAD(NamedType() (<QUESTION_MARK>)? <ANDLITERAL>) All() | Regex()| BonxaiType() )

{
		jjtThis.setNodeType("MixedRegex");
}


}

//All                 ::= NamedType "?"? ( "&" NamedType "?"? )+


void All() #All : {}
{

NamedType() [ <QUESTION_MARK> ] ( <ANDLITERAL> NamedType() [ <QUESTION_MARK> ])+


	{
		jjtThis.setNodeType("All");
	}

}

//Grammar rule:
//# Regex               ::= Regex ( "*" | "+" | "?" | "[" Number ( "," Number )? "]" )?
//#                       | Regex "," Regex
//#                       | Regex "|" Regex
//#                       | "(" Regex ")"
//#                       | NamedType
//# Rule below should avoid left recursion.
//# Warning: The rule is of the form X ::= A (Y_1 | Y_2) | B (Z_1 | Z_2). It contains a nested "or". 
//##
//
//Regex   :: =   "(" Regex ")" ( "*" | "+" | "?" | "[" Number ( "," (NumberOrUnbounded) )? "]" )? 
//                       ( ("," Regex)? | ("|" Regex)? )
//             | NamedType ( "*" | "+" | "?" | "[" Number ( "," NumberOrUnbounded) )? "]" )? 
//                       ( ("," Regex)? | ("|" Regex)? )


void Regex() #Regex : {Integer numberBefore=0; Integer numberAfter=0; Token t=null; Token u=null; String operator=""; String secondoperator="";}
{

 
( <OPENING_ROUND_BRACKET> Regex() { jjtThis.setNodeChoice("regex"); } <CLOSING_ROUND_BRACKET>  
  [ 
    t=<STAR> | t=<PLUS> | t=<QUESTION_MARK> | <OPENING_SQUARED_BRACKET> numberBefore=Number() 
    [ 
      <COMMA>  ( numberAfter=Number() | u=<STAR> ) 
    ]  
    <CLOSING_SQUARED_BRACKET> 
  ] 
  [
    ( <COMMA> Regex()  { jjtThis.setConcatenation(true); } )
       | ( <OR> Regex()   { jjtThis.setDisjunction(true); } )
  ]
  
| 
  NamedType() { jjtThis.setNodeChoice("namedtype"); } 
  [ 
    t=<STAR> | t=<PLUS> | t=<QUESTION_MARK> | <OPENING_SQUARED_BRACKET> numberBefore=Number() 
    [ 
      <COMMA> ( numberAfter=Number() | u=<STAR>  ) 
    ]  
    <CLOSING_SQUARED_BRACKET>
  ]
  [
    ( <COMMA> Regex()  { jjtThis.setConcatenation(true);} )
      | ( <OR> Regex()   { jjtThis.setDisjunction(true); } )
  ] 
) 

	{

 		  operator=(t==null)?"":t.image;
  		  secondoperator=(u==null)?"":u.image;
  
		jjtThis.setOperator(operator);
		jjtThis.setSecondOperator(secondoperator);

		jjtThis.setNumberBefore(numberBefore);
		jjtThis.setNumberAfter(numberAfter);
		jjtThis.setNodeType("Regex");
	}

}


//NamedType           ::= "element" Name ( "{" BonxaiType "}" )?
//                      | "group" Name
//                      | Foreign "element" "*" ( "[" Number ( "," Number )? "]" )? NameSpaceList


// List are generated with 4 entries !

void NamedType() #NamedType : {Vector lst = new Vector();String name=""; String foreign=""; Integer numberBefore=0; Integer numberAfter=0;}
{


( <ELEMENT> name=Name() [ <OPENING_CURLY_BRACKET> BonxaiType() <CLOSING_CURLY_BRACKET> ]  { jjtThis.setNodeChoice("element"); } 
| <GROUP> name=Name()  { jjtThis.setNodeChoice("group"); } 
| foreign=Foreign() <ELEMENT_STAR> [ <OPENING_SQUARED_BRACKET> numberBefore=Number() [ <COMMA> numberAfter=Number() ]  <CLOSING_SQUARED_BRACKET> ] lst=NameSpaceList()  { jjtThis.setNodeChoice("foreign"); }  )


{

		jjtThis.setName(name);
		jjtThis.setForeign(foreign);
		jjtThis.setList(lst);
		jjtThis.setNumberBefore(numberBefore);
		jjtThis.setNumberAfter(numberAfter);
		jjtThis.setNodeType("NamedType");


}

}



//AttributePattern    ::= Foreign "attribute" "*" NameSpaceList ( "," AttributeList )? | AttributeList



void AttributePattern() #AttributePattern : {Vector namespaceLst = new Vector(); String foreign="";  Vector attributeLst = new Vector();}
{

( foreign=Foreign() <ATTRIBUTE> <STAR> namespaceLst= NameSpaceList() [ LOOKAHEAD(2) <COMMA> attributeLst=AttributeList() ] | attributeLst=AttributeList() )


	{
		jjtThis.setNamespaceList(namespaceLst);
		jjtThis.setForeign(foreign);
		jjtThis.setAttributeList(attributeLst);
		jjtThis.setNodeType("AttributePattern");
	}

}



// [old] AttributeList       ::= ( 
//                        "attribute" Name "{" AttrBonxaiType "}" ( "?" )?
//                      | "attribute-group" Name
//                      )
//                      ( "," AttributeList )?

// [new] AttributeList       ::= ( 
//                        "attribute" Name "{" AttrBonxaiType "}" ( "?" )?
//                      | "attribute-group" Name
//                      )
//                      ( "," ( "attribute" Name "{" AttrBonxaiType "}" ( "?" )?
//                      | "attribute-group" Name )
//                      ))*



Vector AttributeList() #AttributeList: {String name; Vector lst = new Vector();}
{

( <ATTRIBUTE> name=Name() {lst.add(name);} <OPENING_CURLY_BRACKET>  AttrBonxaiType() <CLOSING_CURLY_BRACKET> [<QUESTION_MARK> ] 
| <ATTRIBUTEGROUP> name=Name() {lst.add(name);} ) 

( LOOKAHEAD(2) <COMMA> ( <ATTRIBUTE> name=Name() {lst.add(name);} <OPENING_CURLY_BRACKET>  AttrBonxaiType() <CLOSING_CURLY_BRACKET> [<QUESTION_MARK> ] 
| <ATTRIBUTEGROUP> name=Name() {lst.add(name);} ) )*


	{

		jjtThis.setName(name);
		jjtThis.setNodeType("AttributeList");
		jjtThis.setList(lst);
		return lst;
	}

}


// NameSpaceList       ::= "{" Identifier ( "," Identifier )* "}"


Vector NameSpaceList() #NameSpaceList : {Vector lst = new Vector(); Token t;}
{


 <START_LIST>  t=<LIST_LABEL> {lst.add(t.image);} ( <LIST_COMMA> t=<LIST_LABEL> {lst.add(t.image);}  )* <END_LIST> 

{

jjtThis.setNodeType("NameSpaceList");
return lst;

}


}


// Foreign             ::= "strict" | "lax" | "skip"


String Foreign() #Foreign: {}
{

( <STRICT> {return "strict";} | <LAX> {return "lax";} | <SKIPP> {return "skip";} )

{jjtThis.setNodeType("Foreign");}

}


// BonxaiType          ::= "missing" "|" Type DefaultFixedValue?
//                      | Type DefaultFixedValue? "|" "missing"
//                      | Type DefaultFixedValue?


void BonxaiType() #BonxaiType : {Boolean missing=false; Boolean fixed=false; Boolean def=false; String type=""; String name="";}
{

( <MISSING> {missing=true;} <OR> <TYPE> type=Name() [ ( <FIXED> {fixed=true;} name=QuotationName() | <DEFAULTT> {def=true;} name=QuotationName() )]
 | <TYPE> type=Name() [ (<FIXED> {fixed=true;}  name=QuotationName() | <DEFAULTT> {def=true;}  name=QuotationName() )] [<OR> <MISSING> {missing=true;}]

 )

{
		jjtThis.setName(name);
		jjtThis.setFixed(fixed);
		jjtThis.setDefault(def);
		jjtThis.setType(type);
		jjtThis.setMissing(missing);
		jjtThis.setNodeType("Bonxai Type");


}

}


// AttrBonxaiType        ::= Type DefaultFixedValue?

void AttrBonxaiType() #AttrBonxaiType : {Boolean fixed=false; Boolean def=false; String type=""; String name="";}
{

<TYPE> type=Name() [ (<FIXED> {fixed=true;}  name=QuotationName() | <DEFAULTT> {def=true;}   name=QuotationName() )]



{
		jjtThis.setName(name);
		jjtThis.setFixed(fixed);
		jjtThis.setDefault(def);
		jjtThis.setType(type);
		jjtThis.setNodeType("AttrBonXaiType");
}

}


//DefaultFixedValue   ::= "fixed" QuotationName
//                      | "default" QuotationName
// integrated in rules above




// Identifier          ::= ( NCName \ Keywords )
//                      | QuotedIdentifier

String Identifier(): {Token t; String s="" ;}
{

( t=<VAR_LABEL> {s= s+t.image;} | t=<VAROR_LABEL> {s= s+t.image;} )  
//(( t=<VAR_WS> {s=t.image;} | t=<VAROR_WS> {s=t.image;} ))* ( t=<VAR_LABEL> {s= s+t.image;} | t=<VAROR_LABEL> {s= s+t.image;} )  
// | ( (t=<VAROR_WS> {s=t.image;})* t=<VAROR_LABEL> {s= s+t.image;} )


{ return s; } 


}



// QuotedIdentifier    ::= "\" NCName
// not necessary

// QuotationName		::= """ arbitraryLetterExceptQuote """


String QuotationName(): {Token t; String s="" ;}
{

<QUOTE> (t=<QUOT_LABEL>|t=<QUOT_CONSTANT>) {s=t.image;} <QUOT_QUOTE>

{return s;}

}


// Keywords            ::= "empty" | "missing" | "fixed" | "default" | "mixed" | "strict" | "lax" | "skip" | "*"
// implementation not ncessary


// Name                ::= ( (Letter | "_" | ":") (NameChar)* ) \ keywords  | QuotedName
// added: productions like Name:Name; first Name: Namespace (group.bonxai example!)

String Name(): {String s="" ; String t="";}
{

s=Identifier() [(<COLON> | <VAROR_COLON>) t=Identifier() {t=":" + t;} ]

{ return s+t; }


}


// Number              ::= Digit+

Integer  Number() : {Token value;} {

value=<CONSTANT>

{return Integer.valueOf(value.image).intValue();}

}


String NCName(): {} {

{
return "foo";
}

}


// QuotedName          ::= "\" (Letter | "_" | ":") (NameChar)*
// NCName              ::= NCNameStartChar NCNameChar*                
// NCNameChar          ::= NameChar \ ":"
// NCNameStartChar     ::= Letter | "_"
// NameChar            ::= Letter | Digit | "." | "-" | "_" | ":" | CombiningChar | Extender
// not necessary


// http://www.w3.org/TR/REC-xml/#NT-Letter

// [84]   	Letter	   ::=   	 BaseChar | Ideographic

//[85]   BaseChar	


// [86]  Ideographic

// [87]   CombiningChar

// [88]   Digit

// [89]  Extender


// --------------------------------------
// XPath:

// http://www.w3.org/TR/xpath20/#nt-bnf
// [1]    	XPath 	   ::=    	Expr

String XPath(): {} {

Expr_XPath()

{return "Foo";}

}

// [2]    	Expr 	   ::=    	ExprSingle ("," ExprSingle)*

void Expr_XPath(): {} {

ExprSingle() ( LOOKAHEAD(2) < COMMA> ExprSingle())*


}

// [3]    	ExprSingle 	   ::=    	ForExpr | QuantifiedExpr | IfExpr | OrExpr


void ExprSingle(): {} {	

( ForExpr()
| QuantifiedExpr()
| IfExpr()
| OrExpr() )

}

// [4]    	ForExpr 	   ::=    	SimpleForClause "return" ExprSingle

void ForExpr(): {} {

SimpleForClause() <RETURN> ExprSingle()

}


// [5]    	SimpleForClause 	   ::=    	"for" "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)*

void SimpleForClause(): {} {

<FOR> <DOLLAR> VarName() <IN> ExprSingle() (<COMMA> <DOLLAR> VarName() <IN> ExprSingle())*

}

// [6]    	QuantifiedExpr 	   ::=    	("some" | "every") "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)* "satisfies" ExprSingle


void QuantifiedExpr(): {} {

( <SOME> | <EVERY> ) <DOLLAR> VarName() <IN> ExprSingle() ( <COMMA> <DOLLAR> VarName() <IN> ExprSingle())* <SATISFIES> ExprSingle()

}

// [7]    	IfExpr 	   ::=    	"if" "(" Expr ")" "then" ExprSingle "else" ExprSingle


void IfExpr(): {} {

<IF> <OPENING_ROUND_BRACKET> Expr_XPath() <CLOSING_ROUND_BRACKET> <THEN> ExprSingle() <ELSE> ExprSingle() 

}


// [8]    	OrExpr 	   ::=    	AndExpr ( "or" AndExpr )*

void OrExpr(): {} {

AndExpr() ( <OR> AndExpr() )*

}


// [9]    	AndExpr 	   ::=    	ComparisonExpr ( "and" ComparisonExpr )*

void AndExpr(): {} {

ComparisonExpr() ( <AND> ComparisonExpr() )*

}

// [10]    	ComparisonExpr 	   ::=    	RangeExpr ( (ValueComp | GeneralComp | NodeComp) RangeExpr )?


void ComparisonExpr(): {} {

RangeExpr()  
[ (ValueComp()
| GeneralComp()
| NodeComp() ) 
RangeExpr() ]

}

// [11]    	RangeExpr 	   ::=    	AdditiveExpr ( "to" AdditiveExpr )?

void RangeExpr(): {} {

AdditiveExpr() [ <TO> AdditiveExpr() ]

}



// [12]    	AdditiveExpr 	   ::=    	MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*

void AdditiveExpr(): {} {

MultiplicativeExpr() ( (<PLUS> | <MINUS> ) MultiplicativeExpr() )*

} 


// [13]    	MultiplicativeExpr 	   ::=    	UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*

void MultiplicativeExpr(): {} {

UnionExpr() (( <STAR> | <DIV> | <IDIV> | <MOD>) UnionExpr() )*

}


// [14]    	UnionExpr 	   ::=    	IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*


void UnionExpr(): {} {


IntersectExceptExpr() ( LOOKAHEAD(2) ( <UNION> | <OR> ) IntersectExceptExpr() )*


}

// [15]    	IntersectExceptExpr 	   ::=    	InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*

void IntersectExceptExpr(): {} {

InstanceofExpr() ( ( <INTERSECT> | <EXCEPT> ) InstanceofExpr() )*

}

// [16]    	InstanceofExpr 	   ::=    	TreatExpr ( "instance" "of" SequenceType )?

void InstanceofExpr(): {} {

TreatExpr() [ <INSTANCE> <OF> SequenceType() ]


} 


// [17]    	TreatExpr 	   ::=    	CastableExpr ( "treat" "as" SequenceType )?


void TreatExpr(): {} {


CastableExpr() [ <TREAT> <AS> SequenceType() ]

}



// [18]    	CastableExpr 	   ::=    	CastExpr ( "castable" "as" SingleType )?

void CastableExpr(): {} {

CastExpr() [ <CASTABLE> <AS> SingleType() ]

} 


// [19]    	CastExpr 	   ::=    	UnaryExpr ( "cast" "as" SingleType )?

void CastExpr(): {} {

UnaryExpr() [ <CAST> <AS> SingleType() ]

} 




// [20]    	UnaryExpr 	   ::=    	("-" | "+")* ValueExpr

void UnaryExpr(): {} {

 ( LOOKAHEAD(2) <MINUS> | LOOKAHEAD(2) <PLUS> )* ValueExpr()

} 


// [21]    	ValueExpr 	   ::=    	PathExpr

void ValueExpr(): {} {

PathExpr()

} 


// [22]    	GeneralComp 	   ::=    	"=" | "!=" | "<" | "<=" | ">" | ">="


void GeneralComp(): {} { 

( <EQUALS> | <NOTEQUAL> | <LESSTHAN> | <LESSEQUAL> | <GREATERTHAN> | <GREATEREQUAL>)

}


// [23]    	ValueComp 	   ::=    	"eq" | "ne" | "lt" | "le" | "gt" | "ge"


void ValueComp(): {} {

( <EQ> | <NE> | <LT> | <LE> | <GT> | <GE> )


} 


// [24]    	NodeComp 	   ::=    	"is" | "<<" | ">>"

void NodeComp(): {} {

( <IS> | <DBLEFT> | <DBRIGHT> )

} 


// [25]    	PathExpr 	   ::=    	("/" RelativePathExpr?) | ("//" RelativePathExpr) | RelativePathExpr


void PathExpr(): {} {

([ LOOKAHEAD(3) <SLASH> RelativePathExpr()] | LOOKAHEAD(3) <DOUBLESLASH> RelativePathExpr() |  LOOKAHEAD(3) RelativePathExpr() )

} 


// [26]    	RelativePathExpr 	   ::=    	StepExpr (("/" | "//") StepExpr)*


void RelativePathExpr(): {} {


StepExpr() (( <SLASH> | <DOUBLESLASH>) StepExpr() )*

} 

// [27]    	StepExpr 	   ::=    	FilterExpr | AxisStep


void StepExpr(): {} {

 LOOKAHEAD(2) FilterExpr() | LOOKAHEAD(2) AxisStep() 


} 

// [28]    	AxisStep 	   ::=    	(ReverseStep | ForwardStep) PredicateList


void AxisStep(): {} {


(ReverseStep() | ForwardStep() ) PredicateList()

}

// [29]    	ForwardStep 	   ::=    	(ForwardAxis NodeTest) | AbbrevForwardStep


void ForwardStep(): {} {

( ForwardAxis() NodeTest() | AbbrevForwardStep() )

}  

// [30]    	ForwardAxis 	   ::=    	("child" "::")| ("descendant" "::")| ("attribute" "::")| ("self" "::") |
//("descendant-or-self" "::")
//| ("following-sibling" "::")
//| ("following" "::")
//| ("namespace" "::")



void ForwardAxis(): {} {    	
(  <CHILD> <DBCOLON> 
|  <DESCENDANT>  <DBCOLON> 
|  <ATTRIBUTE>  <DBCOLON> 
|  <SELF>  <DBCOLON> 
|  <DESCENDANTORSELF> <DBCOLON> 
|  <FOLLOWINGSIBLING>  <DBCOLON> 
|  <FOLLOWING>  <DBCOLON> 
|  <NAMESPACE>  <DBCOLON>  )

}


// [31]    	AbbrevForwardStep 	   ::=    	"@"? NodeTest


void AbbrevForwardStep(): {} { 

[ <AT> ] NodeTest()

}


// [32]    	ReverseStep 	   ::=    	(ReverseAxis NodeTest) | AbbrevReverseStep


void ReverseStep(): {} {

(ReverseAxis() NodeTest() | AbbrevReverseStep() )

} 

// [33]    	ReverseAxis 	   ::=    	("parent" "::")| ("ancestor" "::")| ("preceding-sibling" "::")| ("preceding""::")
//| ("ancestor-or-self" "::")

void ReverseAxis(): {} { 	   
( <PARENT> <DBCOLON>
| <ANCESTOR> <DBCOLON>
| <PRECEDINGSIBLING> <DBCOLON>
| <PRECEDING> <DBCOLON>
| <ANCESTORORSELF> <DBCOLON> )

}


// [34]    	AbbrevReverseStep 	   ::=    	".."

void AbbrevReverseStep(): {} {

<DBPOINT>

}



// [35]    	NodeTest 	   ::=    	KindTest | NameTest

void NodeTest(): {} {

( KindTest() | NameTest() )


}



// [36]    	NameTest 	   ::=    	QName | Wildcard

void NameTest(): {} {

( LOOKAHEAD(3) QName() | LOOKAHEAD(3) Wildcard() )

} 



//[37]    	Wildcard 	   ::=    	"*" | (NCName ":" "*") | ("*" ":" NCName)

void Wildcard(): {} {

( <STAR> [<COLON> NCName()]
| NCName() <COLON> <STAR>
//| <STAR> <COLON> NCName() 
)

}


// [38]    	FilterExpr 	   ::=    	PrimaryExpr PredicateList

void FilterExpr(): {} {

PrimaryExpr() PredicateList()


}

// [39]    	PredicateList 	   ::=    	Predicate*

void PredicateList(): {} {

(Predicate())*

}

// [40]    	Predicate 	   ::=    	"[" Expr "]"

void Predicate(): {} {

<OPENING_SQUARED_BRACKET> Expr_XPath() <CLOSING_SQUARED_BRACKET>

}

//[41]    	PrimaryExpr 	   ::=    	Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall

void PrimaryExpr(): {} {

( Literal() | VarRef() | ParenthesizedExpr() | ContextItemExpr() | FunctionCall() )

}


// [42]    	Literal 	   ::=    	NumericLiteral | StringLiteral

void Literal(): {} {

( NumericLiteral() | (<BASECHAR>)+ )

}

// [43]    	NumericLiteral 	   ::=    	IntegerLiteral | DecimalLiteral | DoubleLiteral

void NumericLiteral(): {} {

(<DIGIT>)+

} 


// [44]    	VarRef 	   ::=    	"$" VarName

void VarRef(): {} {

<DOLLAR> VarName()

} 


// [45]    	VarName 	   ::=    	QName

void VarName(): {} {

QName()

} 


// [46]    	ParenthesizedExpr 	   ::=    	"(" Expr? ")"

void ParenthesizedExpr(): {} { 

<OPENING_ROUND_BRACKET> Expr_XPath() <CLOSING_ROUND_BRACKET>

// <OPENING_ROUND_BRACKET> [Expr_XPath()] <CLOSING_ROUND_BRACKET>


}

// [47]    	ContextItemExpr 	   ::=    	"."

void ContextItemExpr(): {} { 

<POINT>

}


// [48]    	FunctionCall 	   ::=    	QName "(" (ExprSingle ("," ExprSingle)*)? ")"

void FunctionCall(): {} {

QName() <OPENING_ROUND_BRACKET>  ExprSingle() ( <COMMA> ExprSingle())* <CLOSING_ROUND_BRACKET>

// QName() <OPENING_ROUND_BRACKET>  [ExprSingle() ( <COMMA> ExprSingle()) *] <CLOSING_ROUND_BRACKET>



} 

//  [49]    	SingleType 	   ::=    	AtomicType "?"?

void SingleType(): {} {

AtomicType() [<QUESTION_MARK>]

} 


// [50]    	SequenceType 	   ::=    	("empty-sequence" "(" ")") | (ItemType OccurrenceIndicator?)

void SequenceType(): {} {

( <EMPTYSEQUENCE> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> | [ ItemType() OccurrenceIndicator() ] )

} 


//  [51]    	OccurrenceIndicator 	   ::=    	"?" | "*" | "+"

void OccurrenceIndicator(): {} {

( <QUESTION_MARK> | <STAR> | <PLUS> )

} 

// [52]    	ItemType 	   ::=    	KindTest | ("item" "(" ")") | AtomicType


void ItemType(): {}  {

( KindTest() | <ITEM> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> | AtomicType() )

}

// [53]    	AtomicType 	   ::=    	QName

void AtomicType(): {} {

QName()

} 

// [54]    	KindTest 	   ::=    	DocumentTest| ElementTest| AttributeTest| SchemaElementTest| SchemaAttributeTest
// | PITest| CommentTest| TextTest| AnyKindTest

void KindTest(): {} {
 	  
( DocumentTest()
| ElementTest()
| AttributeTest()
| SchemaElementTest()
| SchemaAttributeTest()
| PITest()
| CommentTest()
| TextTest()
| AnyKindTest() )

}

// [55]    	AnyKindTest 	   ::=    	"node" "(" ")"

void AnyKindTest(): {} {


<NODE> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

} 


// [56]    	DocumentTest 	   ::=    	"document-node" "(" (ElementTest | SchemaElementTest)? ")"

void DocumentTest(): {} { 


<DOCUMENTNODE> <OPENING_ROUND_BRACKET> [ ( ElementTest() | SchemaElementTest() ) ] <CLOSING_ROUND_BRACKET> 

}


// [57]    	TextTest 	   ::=    	"text" "(" ")"


void TextTest(): {} {

<TEXT> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

} 

// [58]    	CommentTest 	   ::=    	"comment" "(" ")"


void CommentTest(): {} { 

<COMMENT> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

}

// [59]    	PITest 	   ::=    	"processing-instruction" "(" (NCName | StringLiteral)? ")"


void PITest(): {} {

<PROCESSINGINSTRUCTION> <OPENING_ROUND_BRACKET>  NCName()   <CLOSING_ROUND_BRACKET> 


} 

// [60]    	AttributeTest 	   ::=    	"attribute" "(" (AttribNameOrWildcard ("," TypeName)?)? ")"


void AttributeTest(): {} {

<OPENING_ROUND_BRACKET>  AttribNameOrWildcard()  <COMMA> TypeName()   <CLOSING_ROUND_BRACKET> 


} 


// [61]    	AttribNameOrWildcard 	   ::=    	AttributeName | "*"


void AttribNameOrWildcard(): {} {  

( AttributeName() | <STAR> )

}


// [62]    	SchemaAttributeTest 	   ::=    	"schema-attribute" "(" AttributeDeclaration ")"

void SchemaAttributeTest(): {} {

<SCHEMAATTRIBUTE> <OPENING_ROUND_BRACKET> AttributeDeclaration() <CLOSING_ROUND_BRACKET> 

} 


// [63]    	AttributeDeclaration 	   ::=    	AttributeName

void AttributeDeclaration(): {} {

AttributeName()

} 

// [64]    	ElementTest 	   ::=    	"element" "(" (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"

void ElementTest(): {} { 

<ELEMENT> <OPENING_ROUND_BRACKET>  ElementNameOrWildcard()  <COMMA> TypeName() <QUESTION_MARK> <CLOSING_ROUND_BRACKET> 

}

// [65]    	ElementNameOrWildcard 	   ::=    	ElementName | "*"

void ElementNameOrWildcard(): {} {

( ElementName() | <STAR> )


} 


// [66]    	SchemaElementTest 	   ::=    	"schema-element" "(" ElementDeclaration ")"

void SchemaElementTest(): {} {

<SCHEMAELEMENT> <OPENING_ROUND_BRACKET> ElementDeclaration() <CLOSING_ROUND_BRACKET> 

} 

// [67]    	ElementDeclaration 	   ::=    	ElementName

void ElementDeclaration(): {} {

ElementName()

} 

// [68]    	AttributeName 	   ::=    	QName

void AttributeName(): {}  {

QName()

}

// [69]    	ElementName 	   ::=    	QName

void ElementName(): {} {

QName()

}


// [70]    	TypeName 	   ::=    	QName

void TypeName(): {} {

QName()

} 



// Qualified Name; http://www.w3.org/TR/REC-xml-names/#NT-QName
// [7]   	QName	   ::=   	PrefixedName | UnprefixedName

void QName(): {} {

//( UnprefixedName() | PrefixedName() )
[LOOKAHEAD(2) Prefix() <COLON>] LocalPart()

}


// [8]   	PrefixedName	   ::=   	Prefix ':' LocalPart

void PrefixedName(): {} {

Prefix() <COLON> LocalPart()

}


// [9]   	UnprefixedName	   ::=   	LocalPart

void UnprefixedName(): {} {

LocalPart()


}


// [10]   	Prefix	   ::=   	NCName

void Prefix(): {} {

NCName()

}


// [11]   	LocalPart	   ::=   	NCName

void LocalPart(): {} {

NCName()

}

//End XPath
//-----------------------------------------

