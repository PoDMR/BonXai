options {
   DEBUG_PARSER = true;
   DEBUG_TOKEN_MANAGER = false;
 }



PARSER_BEGIN(bonXai)

package de.tudortmund.cs.bonxai.bonxai.parser;

import java.io.*;

public class bonXai {
    // Ausgabestrom
    static PrintWriter out = null;

    public static void main(String args[]) throws IOException, ParseException {
	if (args.length < 1 || args.length > 2) {
	    usage();
	    System.exit(1);
	}

	// Ausgabedatei öffnen
	if (args.length == 1) { // Ausgabe auf stdout
	    out = new PrintWriter(System.out, true);
	}
	else { // benannte Ausgabedatei
	    try {
		out = new PrintWriter(new FileOutputStream(args[1]), true);
	    }
	    catch (IOException e) {
		System.out.println("Error opening output file " + args[1] + ", aborting.");
		System.exit(1);
	    }
	}

	Reader rdr = null;

	try { // Eingabedatei öffnen
	    rdr = new BufferedReader(new InputStreamReader(new FileInputStream(args[0])));
	}
	catch (FileNotFoundException e) {
	    System.out.println("Error opening file " + args[0] + ", aborting.");
	    System.exit(1);
	}

	bonXai parser = new bonXai(rdr);

	long startTime = System.currentTimeMillis();
	try {
	    parser.bonXai();  // Eingabedatei interpretieren
	    out.println();
	    out.print("Time expired: "); 
	    out.print(System.currentTimeMillis() - startTime);
	    out.println(" ms");
	    // ggf. weitere statistische Daten ausgeben
	}
	finally {
	    out.close();
	}
    }

    static void usage() {
	System.out.println("usage: java BonXai <input file> [<output file>]");
    }

} 

PARSER_END(bonXai)



SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}




TOKEN :
{
    	<CONSTANT: ( <DIGIT> )+ >
|	<OPENING_ROUND_BRACKET: "("> 
|	<CLOSING_ROUND_BRACKET: ")"> 
|	<OPENING_SQUARED_BRACKET: "["> 
|	<CLOSING_SQUARED_BRACKET: "]"> 
|	<OPENING_CURLY_BRACKET: "{"> 
|	<CLOSING_CURLY_BRACKET: "}">
|	<EQUALS: "="> 
|	<COMMA: ","> 
|	<AT: "@" > 
|	<OR: "|" >
|	<ANDLITERAL: "&">
//|	<LOWERCASE: ["a" - "z"] >
//|	<CAPITLAS: ["A" - "Z"] >
|	<SLASH: "/" >
|	<DOUBLESLASH: "//" >: VARIABLE
|	<BACKSLASH: "\\">
|	<STAR: "*" >
|	<PLUS: "+" >
|	<QUESTION_MARK: "?" >
|	<QUOTE:"\"">:QUOTATION
|	<UNDERSCORE: "_" >
|	<COLON: ":" >:VARIABLE
|	<DBCOLON: "::" >
|	<POINT: ".">
|	<DBPOINT: "..">
|	<MINUS: "-">
//|	<ANNOTATION_VALUE: (~["\n", "\r"])+ >
|	<ANNOTATION_VALUE: "annotaion">






| 	< GRAMMAR: "grammar"  >
|	< DEFAULT_NAMESPACE: "default namespace">
|	< NAMESPACE: "namespace" >: VARIABLE 
|	< TYPE: "type" >:VARIABLE
|	< DEFAULTT: "default" >
|	< DATATYPES: "datatypes " >: VARIABLE
|	< IMPORT: "import" >
|	< CONSTRAINTS: "constraints" >
|	< UNIQUE: "unique" >
|	< KEY: "key" >: VARIABLE
|	< KEYREF: "keyref " >: VARIABLE
|	< GROUPS: "groups" >
|	< GROUP: "group" >: VARIABLE
|	< ATTRIBUTEGROUP: "attribute-group" >: VARIABLE
|	< ATTRIBUTE: "attribute" >: VARIABLE
|	< MIXED: "mixed" >
|	< EMPTY: "empty" >
|	< MISSING: "missing" >
|	< MISSING_OR: "missing |" >
|	< ELEMENT: "element" >: VARIABLE
|	< ELEMENT_STAR: "element *" >:  NAMESPACE_LIST
|	< STRICT: "strict" >
|	< LAX: "lax" >
|	< SKIPP: "skip" >
|	< FIXED: "fixed" >  
|	< RETURN: "return" >  // XPath Token
|	< FOR: "for" >
|	< IN: "in" >
|	< DOLLAR: "$" >
|	< SOME: "some" >
|	< EVERY: "every" >
|	< SATISFIES: "satisfies" >
|	< IF: "if" >
|	< THEN: "then" >
|	< ELSE: "else" >
|	< AND: "and" >
|	< TO: "to" >
|	< DIV: "div" >
|	< IDIV: "idiv" >
|	< MOD: "mod" >
|	< UNION: "union" >
|	< INTERSECT: "intersect" >
|	< EXCEPT: "except" >
|	< INSTANCE: "instance" >
|	< OF: "of" >
|	< TREAT: "treat" >
|	< AS: "as" > 
|	< CASTABLE: "castable" >
|	< CAST: "cast" >
|	< NOTEQUAL: "!=" >
|	< LESSTHAN: "<" >
|	< LESSEQUAL: "<=" >
|	< GREATERTHAN: ">" >
|	< GREATEREQUAL: ">=" >
|	< EQ: "eq"> 
|	< NE: "ne" >
|	< LT: "lt" >
|	< LE: "le" >
|	< GT: "gt" >
|	< GE: "ge" >
|	< IS: "is" >
|	< DBLEFT: "<<" >
|	< DBRIGHT: ">>" >
|	< CHILD: "child" >
|	< DESCENDANT: "descendant" >
|	< SELF: "self" >
|	< DESCENDANTORSELF: "descendant-or-self" >
|	< FOLLOWINGSIBLING: "following-sibling" >
|	< FOLLOWING: "following" >
|	< PARENT: "parent" >
|	< ANCESTOR: "ancestor" >
|	< PRECEDINGSIBLING: "preceding-sibling" >
|	< PRECEDING: "preceding" >
|	< ANCESTORORSELF: "ancestor-or-self" >
|	< EMPTYSEQUENCE: "empty-sequence" >
|	< ITEM: "item" >
|	< NODE: "node" >
|	< DOCUMENTNODE: "document-node" >
|	< TEXT: "text" > 
|	< COMMENT: "comment" > 
|	< PROCESSINGINSTRUCTION: "processing-instruction" >  
|	< SCHEMAATTRIBUTE: "schema-attribute" > 
|	< SCHEMAELEMENT: "schema-element" >

|
	<DIGIT: (["0"-"9"])> |
	<BASECHAR: [ 
		"A"-"Z", 
		"a"-"z", 
		"\u00c0"-"\u00d6",
		"\u00d8"-"\u00f6",
		"\u00f8"-"\u00ff",
		"\u0100"-"\u0131",
	    "\u0134"-"\u013e",
		"\u0141"-"\u0148",
		"\u014a"-"\u017e", 
	    "\u0180"-"\u01c3",
		"\u01cd"-"\u01f0",
		"\u01f4"-"\u01f5",
	    "\u01fa"-"\u0217",
		"\u0250"-"\u02a8",
		"\u02bb"-"\u02c1",
		"\u0386",
		"\u0388"-"\u038a",
		"\u038c",
		"\u038e"-"\u03a1",
		"\u03a3"-"\u03ce",
		"\u03d0"-"\u03d6",
		"\u03da",
		"\u03dc",
		"\u03de",
		"\u03e0",
		"\u0401"-"\u040c",
		"\u03e2"-"\u03f3",
		"\u040e"-"\u044f",
		"\u0451"-"\u045c",
		"\u045e"-"\u0481",
		"\u0490"-"\u04c4",
		"\u04c7"-"\u04c8",
		"\u04cb"-"\u04cc",
		"\u04d0"-"\u04eb",
		"\u04ee"-"\u04f5",
		"\u04f8"-"\u04f9",
		"\u0531"-"\u0556",
		"\u0559", 
		"\u0561"-"\u0586",
		"\u05d0"-"\u05ea",
		"\u05f0"-"\u05f2",
		"\u0621"-"\u063a",
		"\u0641"-"\u064a",
		"\u0671"-"\u06b7",
		"\u06ba"-"\u06be",
		"\u06c0"-"\u06ce",
		"\u06d0"-"\u06d3",
		"\u06d5",
		"\u06e5"-"\u06e6",
		"\u0905"-"\u0939",
		"\u093d",
		"\u0958"-"\u0961",
		"\u0985"-"\u098c",
		"\u098f"-"\u0990",
		"\u0993"-"\u09a8",
		"\u09aa"-"\u09b0",
		"\u09b2",
		"\u09b6"-"\u09b9", 
		"\u09dc"-"\u09dd",
		"\u09df"-"\u09e1",
		"\u09f0"-"\u09f1",
		"\u0a05"-"\u0a0a",
		"\u0a0f"-"\u0a10",
		"\u0a13"-"\u0a28",
		"\u0a2a"-"\u0a30",
		"\u0a32"-"\u0a33",
		"\u0a35"-"\u0a36",
		"\u0a38"-"\u0a39",
		"\u0a59"-"\u0a5c",
		"\u0a5e",
		"\u0a72"-"\u0a74",
		"\u0a85"-"\u0a8b",
		"\u0a8d",
		"\u0a8f"-"\u0a91",
		"\u0a93"-"\u0aa8",
		"\u0aaa"-"\u0ab0",
		"\u0ab2"-"\u0ab3",
		"\u0ab5"-"\u0ab9",
		"\u0abd",
		"\u0ae0",
		"\u0b05"-"\u0b0c",
		"\u0b0f"-"\u0b10",
		"\u0b13"-"\u0b28",
		"\u0b2a"-"\u0b30",
		"\u0b32"-"\u0b33",
		"\u0b36"-"\u0b39",
		"\u0b3d",
		"\u0b5c"-"\u0b5d",
		"\u0b5f"-"\u0b61",
		"\u0b85"-"\u0b8a",
		"\u0b8e"-"\u0b90",
		"\u0b92"-"\u0b95",
		"\u0b99"-"\u0b9a",
		"\u0b9c",
		"\u0b9e"-"\u0b9f",
		"\u0ba3"-"\u0ba4",
		"\u0ba8"-"\u0baa",
		"\u0bae"-"\u0bb5",
		"\u0bb7"-"\u0bb9",
		"\u0c05"-"\u0c0c",
		"\u0c0e"-"\u0c10",
		"\u0c12"-"\u0c28",
		"\u0c2a"-"\u0c33",
		"\u0c35"-"\u0c39",
		"\u0c60"-"\u0c61",
		"\u0c85"-"\u0c8c",
		"\u0c8e"-"\u0c90",
		"\u0c92"-"\u0ca8",
		"\u0caa"-"\u0cb3",
		"\u0cb5"-"\u0cb9",
		"\u0cde",
		"\u0ce0"-"\u0ce1",
		"\u0d05"-"\u0d0c",
		"\u0d0e"-"\u0d10",
		"\u0d12"-"\u0d28",
		"\u0d2a"-"\u0d39",
		"\u0d60"-"\u0d61",
		"\u0e01"-"\u0e2e",
		"\u0e30",
		"\u0e32"-"\u0e33",
		"\u0e40"-"\u0e45",
		"\u0e81"-"\u0e82",
		"\u0e84",
		"\u0e87"-"\u0e88",
		"\u0e8a",
		"\u0e8d",
		"\u0e94"-"\u0e97",
		"\u0e99"-"\u0e9f",
		"\u0ea1"-"\u0ea3",
		"\u0ea5",
		"\u0ea7",
		"\u0eaa"-"\u0eab",
		"\u0ead"-"\u0eae",
		"\u0eb0",
		"\u0eb2"-"\u0eb3",
		"\u0ebd",
		"\u0ec0"-"\u0ec4", 
		"\u0f40"-"\u0f47",
		"\u0f49"-"\u0f69",
		"\u10a0"-"\u10c5",
		"\u10d0"-"\u10f6",
		"\u1100",
		"\u1102"-"\u1103",
		"\u1105"-"\u1107",
		"\u1109",
		"\u110b"-"\u110c",
		"\u110e"-"\u1112",
		"\u113c",
		"\u113e",
		"\u1140",
		"\u114c",
		"\u114e",
		"\u1150",
		"\u1154"-"\u1155",
		"\u1159",
		"\u115f"-"\u1161",
		"\u1163",
		"\u1165",
		"\u1167",
		"\u1169",
		"\u116d"-"\u116e",
		"\u1172"-"\u1173",
		"\u1175",
		"\u119e",
		"\u11a8",
		"\u11ab",
		"\u11ae"-"\u11af",
		"\u11b7"-"\u11b8",
		"\u11ba",
		"\u11bc"-"\u11c2",
		"\u11eb",
		"\u11f0",
		"\u11f9",
		"\u1e00"-"\u1e9b",
		"\u1ea0"-"\u1ef9",
		"\u1f00"-"\u1f15",
		"\u1f18"-"\u1f1d",
		"\u1f20"-"\u1f45",
		"\u1f48"-"\u1f4d",
		"\u1f50"-"\u1f57",
		"\u1f59",
		"\u1f5b","\u1f5d",
		"\u1f5f"-"\u1f7d",
		"\u1f80"-"\u1fb4",
		"\u1fb6"-"\u1fbc",
		"\u1fbe",
		"\u1fc2"-"\u1fc4",
		"\u1fc6"-"\u1fcc",
		"\u1fd0"-"\u1fd3",
		"\u1fd6"-"\u1fdb",
		"\u1fe0"-"\u1fec",
		"\u1ff2"-"\u1ff4",
		"\u1ff6"-"\u1ffc",
		"\u2126",
		"\u212a"-"\u212b",
		"\u212e",
		"\u2180"-"\u2182",
		"\u3041"-"\u3094",
		"\u30a1"-"\u30fa",
		"\u3105"-"\u312c",
		"\uac00"-"\ud7a3"

] > 
| <IDEOGRAPHIC: [
		"\u4e00"-"\u9fa5",
		"\u3007",
		"\u3021"-"\u3029"
	] > |
	
	<COMBINING_CHAR: [
		"\u0300"-"\u0345",
		"\u0360"-"\u0361",
		"\u0483"-"\u0486",
		"\u0591"-"\u05a1",
		"\u05a3"-"\u05b9", 
		"\u05bb"-"\u05bd",
		"\u05bf",
		"\u05c1"-"\u05c2",
		"\u05c4",
		"\u064b"-"\u0652",
		"\u0670",
		"\u06d6"-"\u06dc",
		"\u06dd"-"\u06df",
		"\u06e0"-"\u06e4",
		"\u06e7"-"\u06e8",
		"\u06ea"-"\u06ed",
		"\u0901"-"\u0903",
		"\u093c",
		"\u093e"-"\u094c", 
		"\u094d", 
		"\u0951"-"\u0954",
		"\u0962"-"\u0963", 
		"\u0981"-"\u0983", 
		"\u09bc",
		"\u09be",
		"\u09bf",
		"\u09c0"-"\u09c4", 
		"\u09c7"-"\u09c8", 
		"\u09cb"-"\u09cd", 
		"\u09d7",
		"\u09e2"-"\u09e3",
		"\u0a02", 
		"\u0a3c", "\u0a3e",
		"\u0a3f",
		"\u0a40"-"\u0a42",
		"\u0a47"-"\u0a48",
		"\u0a4b"-"\u0a4d",
		"\u0a70"-"\u0a71",
		"\u0a81"-"\u0a83",
		"\u0abc",
		"\u0abe"-"\u0ac5",
		"\u0ac7"-"\u0ac9",
		"\u0acb"-"\u0acd",
		"\u0b01"-"\u0b03",
		"\u0b3c",
		"\u0b3e"-"\u0b43",
		"\u0b47"-"\u0b48",
		"\u0b4b"-"\u0b4d",
		"\u0b56"-"\u0b57",
		"\u0b82"-"\u0b83",
		"\u0bbe"-"\u0bc2",
		"\u0bc6"-"\u0bc8",
		"\u0bca"-"\u0bcd",
		"\u0bd7",
		"\u0c01"-"\u0c03",
		"\u0c3e"-"\u0c44", 
		"\u0c46"-"\u0c48",
		"\u0c4a"-"\u0c4d",
		"\u0c55"-"\u0c56", 
		"\u0c82"-"\u0c83",
		"\u0cbe"-"\u0cc4",
		"\u0cc6"-"\u0cc8",
		"\u0cca"-"\u0ccd",
		"\u0cd5"-"\u0cd6",
		"\u0d02"-"\u0d03",
		"\u0d3e"-"\u0d43",
		"\u0d46"-"\u0d48",
		"\u0d4a"-"\u0d4d",
		"\u0d57",
		"\u0e31",
		"\u0e34"-"\u0e3a",
		"\u0e47"-"\u0e4e",
		"\u0eb1",
		"\u0eb4"-"\u0eb9",
		"\u0ebb"-"\u0ebc",
		"\u0ec8"-"\u0ecd",
		"\u0f18"-"\u0f19",
		"\u0f35", 
		"\u0f37",
		"\u0f39", 
		"\u0f3e",
		"\u0f3f",
		"\u0f71"-"\u0f84",
		"\u0f86"-"\u0f8b",
		"\u0f90"-"\u0f95",
		"\u0f97",
		"\u0f99"-"\u0fad",
		"\u0fb1"-"\u0fb7",
		"\u0fb9",
		"\u20d0"-"\u20dc",
		"\u20e1", 
		"\u302a"-"\u302f",
		"\u3099",
		"\u309a"
		]> |
	
<EXTENDER: [
		"\u00b7",
		"\u02d0",
		"\u02d1",
		"\u0387",
		"\u0640",
		"\u0e46",
		"\u0ec6",
		"\u3005",
		"\u3031"-"\u3035",
		"\u309d"-"\u309e",
		"\u30fc"-"\u30fe"
		] > 

        


|	<HTTP : "http://" >:URI
|	<FTP : "ftp://" >:URI 
|	<STRING: ":string" > 
|	<INT: ":int" >
|	<CHAR: ":char" >


}

<URI> TOKEN: {

	<URI_LABEL: (<BASECHAR>)+ >
|	<URI_POINT: "." >
|	<URI_SLASH: "/" >
|	<URI_CONSTANT: ( <DIGIT> )+ >
//|	<URI_SEMICOLON: ";"> :DEFAULT 
|	<URI_WS: " "> :DEFAULT 
| 	<URI_ROW: "\r">:DEFAULT
| 	<URI_LINE: "\n">:DEFAULT

}


<VARIABLE> TOKEN: {

	<VAR_LABEL: (<BASECHAR>)+ >:DEFAULT
|	<VAR_CONSTANT: ( <DIGIT> )+ >:DEFAULT
|	<VAR_WS: " ">  


}

<QUOTATION> TOKEN: {

	<QUOT_LABEL: (<BASECHAR>)+ >
|	<QUOT_CONSTANT: ( <DIGIT> )+ >
|	<QOUT_WS: " ">  
|	<QUOT_QUOTE:"\"">:DEFAULT


}


<NAMESPACE_LIST> SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<NAMESPACE_LIST> TOKEN: {

	<LIST_LABEL: (<BASECHAR>)+ >
|	<START_LIST: "{" >
|	<LIST_COMMA: "," >
|	<END_LIST: "}" > :DEFAULT 


}








// Start symbol bonXai(); called by parser function
// Main entry point of the Bonxai grammar
//
// Bonxai              ::= Decl* GroupBlock? Block ConstraintBlock?

void bonXai() : {}
{

( Decl())* [GroupBlock()] Block() [ConstraintBlock()] <EOF>

}

// Decl                ::= "namespace" Identifier "=" NamespaceUriLiteral
//                      | "default" "namespace" NamespaceUriLiteral
//                      | "datatypes" Identifier "=" URL
//                      | "import" NamespaceUriLiteral ( "=" URL )?


void Decl(): {}
{

( <NAMESPACE> Identifier() <EQUALS> NamespaceUriLiteral()
//| <DEFAULTT> <NAMESPACE>  NamespaceUriLiteral()
| <DEFAULT_NAMESPACE> NamespaceUriLiteral()
| <DATATYPES> Identifier() <EQUALS> NamespaceUriLiteral() 
| <IMPORT> NamespaceUriLiteral() [ <EQUALS> NamespaceUriLiteral() ] )

}



void NamespaceUriLiteral(): {}
{

//( <HTTP> | <FTP> )(<BASECHAR>| <CONSTANT> | <SLASH>|<POINT>)+

( <HTTP> | <FTP> )  host() (<URI_WS>|<URI_ROW>|<URI_LINE>)

}

void host(): {}
{

<URI_LABEL> (  (<URI_POINT>|<URI_SLASH>|<URI_CONSTANT>)*  <URI_LABEL>)*

}




// ConstraintBlock     ::= "constraints" "{" Constraint+ "}"
// // is empty constraints possible? ::= "constraints" "{" (Constraint+)? "}"

void ConstraintBlock(): {}
{

<CONSTRAINTS> <OPENING_CURLY_BRACKET> [(Constraint())+] <CLOSING_CURLY_BRACKET>

}

//Constraint          ::= UniqueConstraint | KeyConstraint | KeyRefConstraint

void Constraint(): {}
{

( UniqueConstraint() | KeyConstraint() | KeyRefConstraint() )

}


//UniqueConstraint    ::= "unique" APattern "=" "{" ConstraintSelector ConstraintFields "}"
// EQUALS added ; see constraint example

void UniqueConstraint(): {}
{


<UNIQUE> APattern() <EQUALS> <OPENING_CURLY_BRACKET> ConstraintSelector() ConstraintFields() <CLOSING_CURLY_BRACKET>

}

// KeyConstraint       ::= "key" Name APattern "{" ConstraintSelector ConstraintFields "}"


void KeyConstraint(): {}
{

<KEY> Name() APattern() <EQUALS>  <OPENING_CURLY_BRACKET> ConstraintSelector() ConstraintFields() <CLOSING_CURLY_BRACKET>


}


// KeyRefConstraint    ::= "keyref" Name APattern "{" ConstraintSelector ConstraintFields "}"

void KeyRefConstraint(): {}
{

<KEYREF> Name() APattern() <EQUALS>  <OPENING_CURLY_BRACKET> ConstraintSelector() ConstraintFields() <CLOSING_CURLY_BRACKET>


}

// ConstraintSelector  ::= XPath

void ConstraintSelector(): {}
{

// point added
<POINT> XPath()

}  


// ConstraintFields    ::= "{" XPath ( "," XPath )* "}"

void ConstraintFields(): {}
{

//@ added
<OPENING_CURLY_BRACKET> <AT>  XPath() ( <COMMA> XPath())* <CLOSING_CURLY_BRACKET>

}    

// GroupBlock          ::= "groups" "{" GroupRule+ "}"

 void GroupBlock(): {}
{

<GROUPS> <OPENING_CURLY_BRACKET> [(GroupRule())+] <CLOSING_CURLY_BRACKET>


}

// GroupRule           ::= "group" Name "=" Regex
//                      | "attribute-group" Name "=" "{" AttributePattern "}"

void GroupRule(): {}
{

( <GROUP> Name() <EQUALS> Regex()
| <ATTRIBUTEGROUP> Name() <EQUALS> <OPENING_CURLY_BRACKET> AttributePattern() <CLOSING_CURLY_BRACKET> )


}

//Block               ::= "grammar" "{" Expr+ "}"
// is an empty grammar possible? ::= "grammar" "{" (Expr+)? "}"


void Block() : {}
{

<GRAMMAR> <OPENING_CURLY_BRACKET> [( Expr())+]  <CLOSING_CURLY_BRACKET>

}


// Expr                ::= Annotations? APattern "=" "mixed"? CPattern


void Expr(): {}
{

[Annotations() ] APattern() <EQUALS> [<MIXED>] CPattern()


}


// Annotations         ::= ( Annotation )+

void Annotations(): {}
{

( Annotation())+

}

// Annotation            ::= AnnotationName AnnotationValue

void Annotation(): {}
{

 AnnotationName() AnnotationValue()

}


// AnnotationName      ::= "@" ["a"-"z", "A"-"Z"]+


void AnnotationName(): {}
{

<AT> (<BASECHAR>)+


}

// AnnotationValue     ::= ~["\r", "\n"]+
// the tilde character (~) means NOT to the JavaCC tokenizer.


void AnnotationValue(): {}
{

<ANNOTATION_VALUE>

}


// APattern            ::= SimpleAPattern FullAPattern? | FullAPattern

void APattern(): {}
{

( SimpleAPattern() [ LOOKAHEAD(2) FullAPattern() ] | FullAPattern() )

}


//SimpleAPattern       ::= Name | "(" SimpleAPatternOr ")"


void SimpleAPattern(): {}
{

( Name() | <OPENING_ROUND_BRACKET> SimpleAPatternOr() <CLOSING_ROUND_BRACKET> )

}

// SimpleAPatternOr     ::= SimpleAPattern ("|" SimpleAPattern)*


void SimpleAPatternOr(): {}
{

SimpleAPattern() (<OR> SimpleAPattern())*


}


// FullAPattern       ::=    PathSeparator SimpleAPattern (FullAPattern)?
//                        | "(" FullAPatternOr ")" Operator?


void FullAPattern(): {}
{
(	PathSeparator() SimpleAPattern() [LOOKAHEAD(2) FullAPattern()]
  | (<OPENING_CURLY_BRACKET>  FullAPatternOr() <CLOSING_CURLY_BRACKET> (Operator())?)
  
	)
}



//FullAPatternHead   ::= 	PathSeparator Name 


void FullAPatternHead(): {} {

PathSeparator() Name() 


}   




// FullAPatternOr     ::= FullAPattern ("|" FullAPattern)*

void FullAPatternOr(): {}
{

FullAPattern() (<OR> FullAPattern())*


}


// PathSeparator      ::= "/" | "//"

void PathSeparator(): {}
{

(<SLASH> | <DOUBLESLASH>)

}



// Operator           ::= "*" | "+" | "?"

void Operator(): {}
{

( <STAR> | <PLUS> | <QUESTION_MARK> )

}


// CPattern            ::= "{" ( AttributePattern "," )? ElementPattern "}"

void CPattern(): {}
{

<OPENING_CURLY_BRACKET> [ LOOKAHEAD(2) AttributePattern() <COMMA> ] ElementPattern()  <CLOSING_CURLY_BRACKET>  

}


// ElementPattern      ::= "empty"
//                      | "missing"? MixedRegex


void ElementPattern(): {}
{

( <EMPTY> | [ LOOKAHEAD(2) <MISSING>] MixedRegex() )

}


// MixedRegex          ::= All
//                      | Regex
//                      | BonxaiType

void MixedRegex(): {}
{ 

( LOOKAHEAD(3)All() | LOOKAHEAD(3) Regex()| BonxaiType() )

}

//All                 ::= NamedType "?"? ( "&" NamedType "?"? )+


void All(): {}
{

NamedType() [ <QUESTION_MARK> ] ( <ANDLITERAL> NamedType() [ <QUESTION_MARK> ])+

}

//Regex   :: =   "(" Regex ")" ( "*" | "+" | "?" | "[" Number ( "," Number )? "]" )?
//             | NamedType ( "*" | "+" | "?" | "[" Number ( "," Number )? "]" )?
//             | NamedType "," Regex
//             | NamedType "|" Regex


// Old version: 
// Regex               ::= Regex ( "*" | "+" | "?" | "[" Number ( "," Number )? "]" )?
//                       | Regex "," Regex
//                       | Regex "|" Regex
//                       | "(" Regex ")"
//                       | NamedType


void Regex(): {}
{

 
( <OPENING_ROUND_BRACKET> Regex() <CLOSING_ROUND_BRACKET>  [ ( <STAR> | <PLUS> | <QUESTION_MARK> | <OPENING_SQUARED_BRACKET> Number() [ <COMMA> Number() ]  <CLOSING_SQUARED_BRACKET> | <COMMA> Regex() | <OR> Regex()) ] 
| NamedType() [ ( <STAR> | <PLUS> | <QUESTION_MARK> | <OPENING_SQUARED_BRACKET> Number() [ <COMMA> Number() ]  <CLOSING_SQUARED_BRACKET> | <COMMA> Regex() | <OR> Regex() ) ] 
) 

//( 
//  <OPENING_ROUND_BRACKET> Regex() <CLOSING_ROUND_BRACKET> [ <STAR> ]
//  | 
//  NamedType() 
//) 


}






//NamedType           ::= "element" Name ( "{" BonxaiType "}" )?
//                      | "group" Name
//                      | Foreign "element" "*" ( "[" Number ( "," Number )? "]" )? NameSpaceList


void NamedType(): {}
{


( <ELEMENT> Name() [ <OPENING_CURLY_BRACKET> BonxaiType() <CLOSING_CURLY_BRACKET> ] 
| <GROUP> Name() 
| Foreign() <ELEMENT_STAR> [ <OPENING_SQUARED_BRACKET> Number() [ <COMMA> Number() ]  <CLOSING_SQUARED_BRACKET> ] NameSpaceList() )

}



//AttributePattern    ::= Foreign "attribute" "*" NameSpaceList ( "," AttributeList )? | AttributeList

void AttributePattern(): {}
{

( Foreign() <ATTRIBUTE> <STAR> NameSpaceList() [ LOOKAHEAD(2) <COMMA> AttributeList() ] | AttributeList() )


}



// AttributeList       ::= ( 
//                        "attribute" Name "{" AttrBonxaiType "}" ( "?" )?
//                      | "attribute-group" Name
//                      )
//                      ( "," AttributeList )?


void AttributeList(): {}
{

( <ATTRIBUTE> Name() <OPENING_CURLY_BRACKET>  AttrBonxaiType() <CLOSING_CURLY_BRACKET> [<QUESTION_MARK> ] 
| <ATTRIBUTEGROUP> Name() ) [ LOOKAHEAD(2) <COMMA> AttributeList() ]


}


// NameSpaceList       ::= "{" Identifier ( "," Identifier )* "}"


void NameSpaceList(): {}
{


 <START_LIST>  <LIST_LABEL> ( <LIST_COMMA> <LIST_LABEL> )* <END_LIST> 
}


// Foreign             ::= "strict" | "lax" | "skip"


void Foreign(): {}
{

( <STRICT> | <LAX> | <SKIPP> )


}


// BonxaiType          ::= "missing" "|" Type DefaultFixedValue?
//                      | Type DefaultFixedValue? "|" "missing"
//                      | Type DefaultFixedValue?


void BonxaiType(): {}
{

( <MISSING> <OR> <TYPE> Type() [DefaultFixedValue()]
 | <TYPE> Type() [DefaultFixedValue()] [<OR> <MISSING>]

 )

// is aquivalent to rule above?

}


// AttrBonxaiType        ::= Type DefaultFixedValue?

void AttrBonxaiType(): {}
{

Type() [DefaultFixedValue()]

}


// new Function type(): string, int, char t.b.c
// added: missing productions like: Type:Name



void Type(): {} {


Identifier() ( <CHAR> | <INT> | <STRING> )

 //<VAR_LABEL>  <VAR_COLON> ( <CHAR> | <INT> | <STRING> )

}


//DefaultFixedValue   ::= "fixed" QuotationName
//                      | "default" QuotationName


void DefaultFixedValue(): {}
{


( LOOKAHEAD(3) <FIXED> QuotationName() | <DEFAULTT> QuotationName() )


}



// Identifier          ::= ( NCName \ Keywords )
//                      | QuotedIdentifier

void Identifier(): {}
{

(<VAR_WS>)* <VAR_LABEL> 


}



// QuotedIdentifier    ::= "\" NCName

void QuotedIdentifier(): {}
{

<BACKSLASH> NCName()

}

// QuotationName		::= """ arbitraryLetterExceptQuote """


void QuotationName(): {}
{

<QUOTE> (<QUOT_LABEL>|<QUOT_CONSTANT>) <QUOT_QUOTE>
}


// Keywords            ::= "empty" | "missing" | "fixed" | "default" | "mixed" | "strict" | "lax" | "skip" | "*"

void Keywords(): {}
{

( <EMPTY>
| <MISSING>
| <FIXED>
| <DEFAULTT>
| <MIXED>
| <STRICT>
| <LAX>
| <SKIPP>
| <STAR> )

}


// Name                ::= ( (Letter | "_" | ":") (NameChar)* ) \ keywords  | QuotedName
// added: productions like Name:Name; first Name: Namespace (group.bonxai example!)

void Name():{} {

Identifier() [<COLON> Identifier()]

//[<VAR_COLON> <VAR_LABEL>] ((<VAR_WS>)+|<VAR_ROW>)


}


// QuotedName          ::= "\" (Letter | "_" | ":") (NameChar)*

void QuotedName(): {}
{

<BACKSLASH> (Letter() | <UNDERSCORE> | <COLON>) (NameChar())*

}


// NCName              ::= NCNameStartChar NCNameChar*                

void NCName(): {}
{

NCNameStartChar() ( LOOKAHEAD(2) NCNameChar())*                
               

}


// NCNameChar          ::= NameChar \ ":"


void NCNameChar():{} {

 NameChar()
// (~[<COLON>])

}



// NCNameStartChar     ::= Letter | "_"

void NCNameStartChar(): {}
{

(Letter() | <UNDERSCORE>)

}

// NameChar            ::= Letter | Digit | "." | "-" | "_" | ":" | CombiningChar | Extender


void NameChar(): {} 
{

( Letter()
| Digit()
| <POINT>
| <MINUS>
| <UNDERSCORE>
| <COLON>
| CombiningChar()
| Extender() )



}


// Number              ::= Digit+

void Number(): {} {
<CONSTANT>
}


// http://www.w3.org/TR/REC-xml/#NT-Letter

// [84]   	Letter	   ::=   	 BaseChar | Ideographic

void Letter(): {} {

( BaseChar() | Ideographic() )

}


//[85]   BaseChar	

void BaseChar(): {} {

<BASECHAR>

}


// [86]  Ideographic

void Ideographic(): {} {

<IDEOGRAPHIC>

}


// [87]   CombiningChar


void CombiningChar(): {}


{
<COMBINING_CHAR>

}


// [88]   Digit

void Digit(): {} {

<DIGIT>

}


// [89]  Extender

 void	Extender(): {} {

<EXTENDER>

}




// --------------------------------------
// XPath:

// http://www.w3.org/TR/xpath20/#nt-bnf
// [1]    	XPath 	   ::=    	Expr

void XPath(): {} {

Expr_XPath()

}

// [2]    	Expr 	   ::=    	ExprSingle ("," ExprSingle)*

void Expr_XPath(): {} {

ExprSingle() ( LOOKAHEAD(2) < COMMA> ExprSingle())*


}

// [3]    	ExprSingle 	   ::=    	ForExpr | QuantifiedExpr | IfExpr | OrExpr


void ExprSingle(): {} {	

( ForExpr()
| QuantifiedExpr()
| IfExpr()
| OrExpr() )

}

// [4]    	ForExpr 	   ::=    	SimpleForClause "return" ExprSingle

void ForExpr(): {} {

SimpleForClause() <RETURN> ExprSingle()

}


// [5]    	SimpleForClause 	   ::=    	"for" "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)*

void SimpleForClause(): {} {

<FOR> <DOLLAR> VarName() <IN> ExprSingle() (<COMMA> <DOLLAR> VarName() <IN> ExprSingle())*

}

// [6]    	QuantifiedExpr 	   ::=    	("some" | "every") "$" VarName "in" ExprSingle ("," "$" VarName "in" ExprSingle)* "satisfies" ExprSingle


void QuantifiedExpr(): {} {

( <SOME> | <EVERY> ) <DOLLAR> VarName() <IN> ExprSingle() ( <COMMA> <DOLLAR> VarName() <IN> ExprSingle())* <SATISFIES> ExprSingle()

}

// [7]    	IfExpr 	   ::=    	"if" "(" Expr ")" "then" ExprSingle "else" ExprSingle


void IfExpr(): {} {

<IF> <OPENING_ROUND_BRACKET> Expr_XPath() <CLOSING_ROUND_BRACKET> <THEN> ExprSingle() <ELSE> ExprSingle() 

}


// [8]    	OrExpr 	   ::=    	AndExpr ( "or" AndExpr )*

void OrExpr(): {} {

AndExpr() ( <OR> AndExpr() )*

}


// [9]    	AndExpr 	   ::=    	ComparisonExpr ( "and" ComparisonExpr )*

void AndExpr(): {} {

ComparisonExpr() ( <AND> ComparisonExpr() )*

}

// [10]    	ComparisonExpr 	   ::=    	RangeExpr ( (ValueComp | GeneralComp | NodeComp) RangeExpr )?


void ComparisonExpr(): {} {

RangeExpr()  
[ (ValueComp()
| GeneralComp()
| NodeComp() ) 
RangeExpr() ]

}

// [11]    	RangeExpr 	   ::=    	AdditiveExpr ( "to" AdditiveExpr )?

void RangeExpr(): {} {

AdditiveExpr() [ <TO> AdditiveExpr() ]

}



// [12]    	AdditiveExpr 	   ::=    	MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*

void AdditiveExpr(): {} {

MultiplicativeExpr() ( (<PLUS> | <MINUS> ) MultiplicativeExpr() )*

} 


// [13]    	MultiplicativeExpr 	   ::=    	UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*

void MultiplicativeExpr(): {} {

UnionExpr() (( <STAR> | <DIV> | <IDIV> | <MOD>) UnionExpr() )*

}


// [14]    	UnionExpr 	   ::=    	IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*


void UnionExpr(): {} {


IntersectExceptExpr() ( LOOKAHEAD(2) ( <UNION> | <OR> ) IntersectExceptExpr() )*


}

// [15]    	IntersectExceptExpr 	   ::=    	InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*

void IntersectExceptExpr(): {} {

InstanceofExpr() ( ( <INTERSECT> | <EXCEPT> ) InstanceofExpr() )*

}

// [16]    	InstanceofExpr 	   ::=    	TreatExpr ( "instance" "of" SequenceType )?

void InstanceofExpr(): {} {

TreatExpr() [ <INSTANCE> <OF> SequenceType() ]


} 


// [17]    	TreatExpr 	   ::=    	CastableExpr ( "treat" "as" SequenceType )?


void TreatExpr(): {} {


CastableExpr() [ <TREAT> <AS> SequenceType() ]

}



// [18]    	CastableExpr 	   ::=    	CastExpr ( "castable" "as" SingleType )?

void CastableExpr(): {} {

CastExpr() [ <CASTABLE> <AS> SingleType() ]

} 


// [19]    	CastExpr 	   ::=    	UnaryExpr ( "cast" "as" SingleType )?

void CastExpr(): {} {

UnaryExpr() [ <CAST> <AS> SingleType() ]

} 




// [20]    	UnaryExpr 	   ::=    	("-" | "+")* ValueExpr

void UnaryExpr(): {} {

 ( LOOKAHEAD(2) <MINUS> | LOOKAHEAD(2) <PLUS> )* ValueExpr()

} 


// [21]    	ValueExpr 	   ::=    	PathExpr

void ValueExpr(): {} {

PathExpr()

} 


// [22]    	GeneralComp 	   ::=    	"=" | "!=" | "<" | "<=" | ">" | ">="


void GeneralComp(): {} { 

( <EQUALS> | <NOTEQUAL> | <LESSTHAN> | <LESSEQUAL> | <GREATERTHAN> | <GREATEREQUAL>)

}


// [23]    	ValueComp 	   ::=    	"eq" | "ne" | "lt" | "le" | "gt" | "ge"


void ValueComp(): {} {

( <EQ> | <NE> | <LT> | <LE> | <GT> | <GE> )


} 


// [24]    	NodeComp 	   ::=    	"is" | "<<" | ">>"

void NodeComp(): {} {

( <IS> | <DBLEFT> | <DBRIGHT> )

} 


// [25]    	PathExpr 	   ::=    	("/" RelativePathExpr?) | ("//" RelativePathExpr) | RelativePathExpr


void PathExpr(): {} {

([ LOOKAHEAD(3) <SLASH> RelativePathExpr()] | LOOKAHEAD(3) <DOUBLESLASH> RelativePathExpr() |  LOOKAHEAD(3) RelativePathExpr() )

} 


// [26]    	RelativePathExpr 	   ::=    	StepExpr (("/" | "//") StepExpr)*


void RelativePathExpr(): {} {


StepExpr() (( <SLASH> | <DOUBLESLASH>) StepExpr() )*

} 

// [27]    	StepExpr 	   ::=    	FilterExpr | AxisStep


void StepExpr(): {} {

( LOOKAHEAD(2) FilterExpr() | LOOKAHEAD(2) AxisStep() )*


} 

// [28]    	AxisStep 	   ::=    	(ReverseStep | ForwardStep) PredicateList


void AxisStep(): {} {


(ReverseStep() | ForwardStep() ) PredicateList()

}

// [29]    	ForwardStep 	   ::=    	(ForwardAxis NodeTest) | AbbrevForwardStep


void ForwardStep(): {} {

( ForwardAxis() NodeTest() | AbbrevForwardStep() )

}  

// [30]    	ForwardAxis 	   ::=    	("child" "::")| ("descendant" "::")| ("attribute" "::")| ("self" "::") |
//("descendant-or-self" "::")
//| ("following-sibling" "::")
//| ("following" "::")
//| ("namespace" "::")



void ForwardAxis(): {} {    	
(  <CHILD> <DBCOLON> 
|  <DESCENDANT>  <DBCOLON> 
|  <ATTRIBUTE>  <DBCOLON> 
|  <SELF>  <DBCOLON> 
|  <DESCENDANTORSELF> <DBCOLON> 
|  <FOLLOWINGSIBLING>  <DBCOLON> 
|  <FOLLOWING>  <DBCOLON> 
|  <NAMESPACE>  <DBCOLON>  )

}


// [31]    	AbbrevForwardStep 	   ::=    	"@"? NodeTest


void AbbrevForwardStep(): {} { 

[ <AT> ] NodeTest()

}


// [32]    	ReverseStep 	   ::=    	(ReverseAxis NodeTest) | AbbrevReverseStep


void ReverseStep(): {} {

(ReverseAxis() NodeTest() | AbbrevReverseStep() )

} 

// [33]    	ReverseAxis 	   ::=    	("parent" "::")| ("ancestor" "::")| ("preceding-sibling" "::")| ("preceding""::")
//| ("ancestor-or-self" "::")

void ReverseAxis(): {} { 	   
( <PARENT> <DBCOLON>
| <ANCESTOR> <DBCOLON>
| <PRECEDINGSIBLING> <DBCOLON>
| <PRECEDING> <DBCOLON>
| <ANCESTORORSELF> <DBCOLON> )

}


// [34]    	AbbrevReverseStep 	   ::=    	".."

void AbbrevReverseStep(): {} {

<DBPOINT>

}



// [35]    	NodeTest 	   ::=    	KindTest | NameTest

void NodeTest(): {} {

( KindTest() | NameTest() )


}



// [36]    	NameTest 	   ::=    	QName | Wildcard

void NameTest(): {} {

( LOOKAHEAD(3) QName() | LOOKAHEAD(3) Wildcard() )

} 



//[37]    	Wildcard 	   ::=    	"*" | (NCName ":" "*") | ("*" ":" NCName)

void Wildcard(): {} {

( <STAR> [<COLON> NCName()]
| NCName() <COLON> <STAR>
//| <STAR> <COLON> NCName() 
)

}


// [38]    	FilterExpr 	   ::=    	PrimaryExpr PredicateList

void FilterExpr(): {} {

PrimaryExpr() PredicateList()


}

// [39]    	PredicateList 	   ::=    	Predicate*

void PredicateList(): {} {

(Predicate())*

}

// [40]    	Predicate 	   ::=    	"[" Expr "]"

void Predicate(): {} {

<OPENING_SQUARED_BRACKET> Expr_XPath() <CLOSING_SQUARED_BRACKET>

}

//[41]    	PrimaryExpr 	   ::=    	Literal | VarRef | ParenthesizedExpr | ContextItemExpr | FunctionCall

void PrimaryExpr(): {} {

( Literal() | VarRef() | ParenthesizedExpr() | ContextItemExpr() | FunctionCall() )

}


// [42]    	Literal 	   ::=    	NumericLiteral | StringLiteral

void Literal(): {} {

( NumericLiteral() | (<BASECHAR>)+ )

}

// [43]    	NumericLiteral 	   ::=    	IntegerLiteral | DecimalLiteral | DoubleLiteral

void NumericLiteral(): {} {

(<DIGIT>)+

} 


// [44]    	VarRef 	   ::=    	"$" VarName

void VarRef(): {} {

<DOLLAR> VarName()

} 


// [45]    	VarName 	   ::=    	QName

void VarName(): {} {

QName()

} 


// [46]    	ParenthesizedExpr 	   ::=    	"(" Expr? ")"

void ParenthesizedExpr(): {} { 

<OPENING_ROUND_BRACKET> Expr_XPath() <CLOSING_ROUND_BRACKET>

// <OPENING_ROUND_BRACKET> [Expr_XPath()] <CLOSING_ROUND_BRACKET>


}

// [47]    	ContextItemExpr 	   ::=    	"."

void ContextItemExpr(): {} { 

<POINT>

}


// [48]    	FunctionCall 	   ::=    	QName "(" (ExprSingle ("," ExprSingle)*)? ")"

void FunctionCall(): {} {

QName() <OPENING_ROUND_BRACKET>  ExprSingle() ( <COMMA> ExprSingle())* <CLOSING_ROUND_BRACKET>

// QName() <OPENING_ROUND_BRACKET>  [ExprSingle() ( <COMMA> ExprSingle()) *] <CLOSING_ROUND_BRACKET>



} 

//  [49]    	SingleType 	   ::=    	AtomicType "?"?

void SingleType(): {} {

AtomicType() [<QUESTION_MARK>]

} 


// [50]    	SequenceType 	   ::=    	("empty-sequence" "(" ")") | (ItemType OccurrenceIndicator?)

void SequenceType(): {} {

( <EMPTYSEQUENCE> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> | [ ItemType() OccurrenceIndicator() ] )

} 


//  [51]    	OccurrenceIndicator 	   ::=    	"?" | "*" | "+"

void OccurrenceIndicator(): {} {

( <QUESTION_MARK> | <STAR> | <PLUS> )

} 

// [52]    	ItemType 	   ::=    	KindTest | ("item" "(" ")") | AtomicType


void ItemType(): {}  {

( KindTest() | <ITEM> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> | AtomicType() )

}

// [53]    	AtomicType 	   ::=    	QName

void AtomicType(): {} {

QName()

} 

// [54]    	KindTest 	   ::=    	DocumentTest| ElementTest| AttributeTest| SchemaElementTest| SchemaAttributeTest
// | PITest| CommentTest| TextTest| AnyKindTest

void KindTest(): {} {
 	  
( DocumentTest()
| ElementTest()
| AttributeTest()
| SchemaElementTest()
| SchemaAttributeTest()
| PITest()
| CommentTest()
| TextTest()
| AnyKindTest() )

}

// [55]    	AnyKindTest 	   ::=    	"node" "(" ")"

void AnyKindTest(): {} {


<NODE> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

} 


// [56]    	DocumentTest 	   ::=    	"document-node" "(" (ElementTest | SchemaElementTest)? ")"

void DocumentTest(): {} { 


<DOCUMENTNODE> <OPENING_ROUND_BRACKET> [ ( ElementTest() | SchemaElementTest() ) ] <CLOSING_ROUND_BRACKET> 

}


// [57]    	TextTest 	   ::=    	"text" "(" ")"


void TextTest(): {} {

<TEXT> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

} 

// [58]    	CommentTest 	   ::=    	"comment" "(" ")"


void CommentTest(): {} { 

<COMMENT> <OPENING_ROUND_BRACKET> <CLOSING_ROUND_BRACKET> 

}

// [59]    	PITest 	   ::=    	"processing-instruction" "(" (NCName | StringLiteral)? ")"


void PITest(): {} {

<PROCESSINGINSTRUCTION> <OPENING_ROUND_BRACKET> [ (NCName() ) ] <CLOSING_ROUND_BRACKET> 


} 

// [60]    	AttributeTest 	   ::=    	"attribute" "(" (AttribNameOrWildcard ("," TypeName)?)? ")"


void AttributeTest(): {} {

<OPENING_ROUND_BRACKET> [ AttribNameOrWildcard() [ <COMMA> TypeName() ]]  <CLOSING_ROUND_BRACKET> 


} 


// [61]    	AttribNameOrWildcard 	   ::=    	AttributeName | "*"


void AttribNameOrWildcard(): {} {  

( AttributeName() | <STAR> )

}


// [62]    	SchemaAttributeTest 	   ::=    	"schema-attribute" "(" AttributeDeclaration ")"

void SchemaAttributeTest(): {} {

<SCHEMAATTRIBUTE> <OPENING_ROUND_BRACKET> AttributeDeclaration() <CLOSING_ROUND_BRACKET> 

} 


// [63]    	AttributeDeclaration 	   ::=    	AttributeName

void AttributeDeclaration(): {} {

AttributeName()

} 

// [64]    	ElementTest 	   ::=    	"element" "(" (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"

void ElementTest(): {} { 

<ELEMENT> <OPENING_ROUND_BRACKET> [ ElementNameOrWildcard() [ <COMMA> TypeName() [<QUESTION_MARK>]]] <CLOSING_ROUND_BRACKET> 

}

// [65]    	ElementNameOrWildcard 	   ::=    	ElementName | "*"

void ElementNameOrWildcard(): {} {

( ElementName() | <STAR> )


} 


// [66]    	SchemaElementTest 	   ::=    	"schema-element" "(" ElementDeclaration ")"

void SchemaElementTest(): {} {

<SCHEMAELEMENT> <OPENING_ROUND_BRACKET> ElementDeclaration() <CLOSING_ROUND_BRACKET> 

} 

// [67]    	ElementDeclaration 	   ::=    	ElementName

void ElementDeclaration(): {} {

ElementName()

} 

// [68]    	AttributeName 	   ::=    	QName

void AttributeName(): {}  {

QName()

}

// [69]    	ElementName 	   ::=    	QName

void ElementName(): {} {

QName()

}


// [70]    	TypeName 	   ::=    	QName

void TypeName(): {} {

QName()

} 



// Qualified Name; http://www.w3.org/TR/REC-xml-names/#NT-QName
// [7]   	QName	   ::=   	PrefixedName | UnprefixedName

void QName(): {} {

//( UnprefixedName() | PrefixedName() )
[LOOKAHEAD(2) Prefix() <COLON>] LocalPart()

}


// [8]   	PrefixedName	   ::=   	Prefix ':' LocalPart

void PrefixedName(): {} {

Prefix() <COLON> LocalPart()

}


// [9]   	UnprefixedName	   ::=   	LocalPart

void UnprefixedName(): {} {

LocalPart()


}


// [10]   	Prefix	   ::=   	NCName

void Prefix(): {} {

NCName()

}


// [11]   	LocalPart	   ::=   	NCName

void LocalPart(): {} {

NCName()

}

//End XPath
//-----------------------------------------

