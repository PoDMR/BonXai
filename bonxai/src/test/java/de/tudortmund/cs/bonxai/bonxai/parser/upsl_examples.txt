; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> No Mixed Regex
;	This is the easiest example

grammar{
	//root ={
		empty
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (1. No (?)) (2.) 
;	NamedType		=> element (no (?)), group
;	Here are two NamedTypes for All(MixedType) tested

grammar{
	//root ={
		element node1 & group group1
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType 
;	NamedType		=> element, groups
;	The same example. There are just "?" after NamedType used

grammar{
	//root ={
		element node1? & group group1?
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (no (?)), group, Foreign (no (?))
;	Foreign			=> strict
;	NameSpaceList	=> identifier (NCName\Keywords)
;	NCName			=> NCNameStartChar (Letter) (No(NCNameChar*) used)
;	Here is shown the third row of NamedType, wich use as foreign "stricct" and one NameSpaceList

grammar{
	//root ={
		element node1? & group group1? & strict element* { N }
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (no (?)), group, Foreign (no (?))
;	Foreign			=> strict
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_) (NCNameChar* used)
;	The same example with two NameSpaceList

grammar{
	//root ={
		element node1? & group group1? & strict element* {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (no (?)), group, Foreign (outter(?))
;	Foreign			=> skip
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_) (NCNameChar* used)
;	The same example, for foreign "skip" and one Number field

grammar{
	//root ={
		element node1? & group group1? & skip element* [543] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (no (?)), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	The same example, for foreign "lax" and two Number field

grammar{
	//root ={
		element node1? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (UpslType used), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	UpslType		=> 1.row (no(?))
;	UpslType is used in Named Type. first row of UpslType without DefaultFixedValue

grammar{
	//root ={
		element node1{missing|Type}? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (UpslType used), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	UpslType		=> 1.row, fixed, QuotationName
;	The same example, DefaultFixedValue is "fixed" with name \a

grammar{
	//root ={
		element node1{missing | Type fixed "\a" }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (UpslType used), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	UpslType		=> 2.row, No DefaultFixedValue
;	The second row of UpslType is tested, no DefaultFixedValue

grammar{
	//root ={
		element node1{Type | missing }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (UpslType used), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	UpslType		=> 2.row, DefaultFixedValue
;	DefaultFixedValue=>default QuotationName
;	The same example, now DefaultFixedValue is "default"

grammar{
	//root ={
		element node1{Type default "\_name" | missing }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> No Decl, Groupblock and ConstraintBlock
; 	Block			=> Komplettly used 
; 	Expr 			=> No Annotations and "mixed"
; 	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All				=> NamedType (+) used
;	NamedType		=> element (UpslType used), group, Foreign (both(?))
;	Foreign			=> lax
;	NameSpaceList	=> identifier (NCName\Keywords) (*)
;	NCName			=> NCNameStartChar (_)(NCNameChar* used)
;	UpslType		=> 3.row, DefaultFixedValue
;	DefaultFixedValue=>fixed QuotationName
;	The third row of UpslType is tested, "default" used

grammar{
	//root ={
		element node1{Type fixed "\_name" }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> Decl, No Groupblock and No ConstraintBlock
;	Decl			=> all combinations
;	Block			=> Komplettly used 
;	Expr 			=> No Annotations and "mixed"
;	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	All Decl forms are tested in this example

namespace \name1 = NaSpaUriLi
default namespace NaSpaUriLi
dataTypes name2 = http://example.org/namespace
import NaSpaUriLi1 

grammar{
	//root ={
		element node1{Type fixed "\_name" }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


; 	Upsl 			=> Decl, No Groupblock and No ConstraintBlock
;	Decl			=> all combinations
;	GroupBlock		=> Grouprule
;	Block			=> Komplettly used 
;	Expr 			=> No Annotations and "mixed"
;	APattern		=> No (*) used
; 	CPattern		=> No (?) used
; 	ElementPattern	=> Mixed Regex
;	Mixed Regex		=> All
;	GroupBlock is completly tested. many variation are used

namespace name1 = http://www.grafvonrotz.de
default namespace https://wow.wendelin.de:79/gruen/blau
datatypes dt1 = http://example.org/namespace
import http://www.hog.de = http://www.w3.org/XML/1998/namespace

groups { 
	group group1 = group group2
	attribute-group attrgroup1 = attribute someAttribute { Type default "87" } ? , attribute-group attrgroup2 
	attribute-group attrgroup3 = strict attribute * { name3 } attribute-group attrgroup4
}

grammar{
	//root ={
		element node1{Type fixed "\_name" }? & group group1? & lax element* [543,667] {_Namespaces1,Namespace2}
	}
}


;	ConstraintBlock => UniqueConstraint is tested
;	I am sure there is a problem with the names in constraints block
;	This will be fixed later

default namespace http://example.org/namespace
grammar {
	/shop = {
		element categories
	}
	/shop/categories = {
		element category+
	}
	category = {
		attribute id {string},
		string
	}
}

constraints {
	unique /shop/categories/category {
		/id {
			/name1
		}
	}
}


;	ConstraintBlock => KeyConstraint is tested
;	I am sure there is a problem with the names in constraints block
;	This will be fixed later

default namespace http://example.org/namespace
grammar {
	/shop = {
		element categories
	}
	/shop/categories = {
		element category+
	}
	category = {
		attribute id {string},
		string
	}
}

constraints {
	key Keyname1 /shop/categories {
		/id {
			/name2,
			/name3
		}
	}
}


;	ConstraintBlock => KeyrefConstraint is tested
;	I am sure there is a problem with the names in constraints block
;	This will be fixed later

default namespace http://example.org/namespace
grammar {
	/shop = {
		element categories
	}
	/shop/categories = {
		element category+
	}
	category = {
		attribute id {string},
		string
	}
}

constraints {
	keyref Keyrefname1 /shop/categories {
		/id{
			/name4
		}
	}
}

;	Block => Expr
;	Expr => kompletly used
;	CPattern => Attributepatern 
;	Attributepattern => Attributelist
;	Annotations and attributepattern are tested. Regex is tested too(just 1. row) 

grammar {
	@Annotation annotationvalue1 
	//foo = mixed {strict attribute * { Namespacelist1 }
	, element element1 [123 , 234]}
}

;	...ElementPattern => MixedRegex
;	MixedRegex => Regex
;	Regex => all combination
;	All regex variations are tested in this example

grammar {
	@Annotation annotationvalue1 
	//foo = mixed { lax attribute * { Namespacelist1 } 
	, element element1 *, element element2 + | element element3,
	( element element4 )
	}
}


